package main
import(
	"io"
	"math"
	"reflect"
	"unsafe"
	"ethos/llrb"
	"os"
	"bytes"
	"encoding/hex"
	"time"
	"fmt"
	"ethos/syscall"
	"ethos/defined"
	
	"ethos/goodmiddleman"
	
	"log"
	
)

// FIXME: this is a place holder for bytes. bytes is only used when there is an any type
var xxx = bytes.MinRead
var yyy hex.InvalidHexCharError
var sunday = time.Sunday // this needs to be remove after we fixed the sleep in Ipc and IpcWrite.
var the_import_is_not_used_error_is_not_helpful_It_depends_if_need_syscall_and_Ill_know_that_much_later syscall.Fd
var blah_blah_blah_MR_Freeman_blah_blah_blah defined.Rpc

type Int8 int8
type Uint8 uint8
type Int16 int16
type Uint16 uint16
type Int32 int32
type Uint32 uint32
type Int64 int64
type Uint64 uint64
type Float32 float32
type Float64 float64
type Bool bool
type Byte byte
type String string
func Ipc(hostname string, serviceName string) (syscall.Fd, syscall.Status) {
     serviceFd, status := goodmiddleman.OpenDirectory("/services/" + serviceName)
     if status != syscall.StatusOk {
                  log.Fatalf ("Error calling OpenDirectory /services/%s: %v\n", serviceName, status)
		  return 0, status
     }

     sName := serviceName
     for i:=len(serviceName)-1; i>=0; i-- {
         if (serviceName[i]=='/') {
      	   sName = serviceName[i+1:]
      	}
     }


     netFd, status := goodmiddleman.IpcRepeat(serviceFd, sName, hostname, nil)
     if status != syscall.StatusOk {
                log.Fatalf ("Error calling Ipc: %v\n", status)
	    return 0, status
     }
     return netFd, syscall.StatusOk
}

func Advertise(serviceName string) (listeningFd syscall.Fd, status syscall.Status) {
	serviceFd, status := goodmiddleman.OpenDirectory("/services/" + serviceName)
	if status != syscall.StatusOk {
		log.Fatalf ("Error calling OpenDirectory /services/%s: %v\n", serviceName, status)
		return 0, status
	}

	listeningFd, status = goodmiddleman.Advertise (serviceFd, serviceName)
	if status != syscall.StatusOk {
		log.Fatalf ("Error calling Advertise: %v\n", status)
		return 0, status     
	}

	return listeningFd, status
}

func Import(listeningFd syscall.Fd) (user []byte, fd syscall.Fd, status syscall.Status) {
     user, netFd, status := goodmiddleman.Import (listeningFd)
     if status != syscall.StatusOk {
                log.Fatalf ("Error calling Import: %v\n", status)
		return []byte{}, 0, status
     }
     return user, netFd, syscall.StatusOk
}

type EncoderDecoderFd struct {
     E *Encoder
     D *Decoder
     Fd syscall.Fd
}

func IpcEncoderDecoder(hostname string, serviceName string) (EncoderDecoderFd, syscall.Status) {
     var ed EncoderDecoderFd
     serviceFd, status := goodmiddleman.OpenDirectory("/services/" + serviceName)
     if status != syscall.StatusOk {
		  return ed, status
     }

     sName := serviceName
     for i:=len(serviceName)-1; i>=0; i-- {
         if (serviceName[i]=='/') {
      	   sName = serviceName[i+1:]
      	}
     }


     netFd, status := goodmiddleman.IpcRepeat(serviceFd, sName, hostname, nil)
     if status != syscall.StatusOk {
	    return ed, status	
     }
     writer := goodmiddleman.NewWriter(netFd)
     reader := goodmiddleman.NewReader(netFd)
     goodmiddleman.Close(serviceFd)
     e := NewEncoder(writer)
     d := NewDecoder(reader)
     ed.E = e
     ed.D = d
     ed.Fd = netFd
     return ed, syscall.StatusOk     
}

func (ed *EncoderDecoderFd) Close() {
     goodmiddleman.Close(ed.Fd)
}

const(
	
	
	methodIdMyRpcIncrement = iota
	
	
	
	methodIdMyRpcIncrementReply
	
	
)

func (e *Encoder) MyRpcIncrement() (err os.Error){
     err = e.uint64(methodIdMyRpcIncrement)
     if err != nil {
     	return err
     }
     
     err = e.Flush()
     if err != nil {
     	return err
     }
     return err
}

func (e *Encoder) MyRpcIncrementReply(count uint64) (err os.Error){
     err = e.uint64(methodIdMyRpcIncrementReply)
     if err != nil {
     	return err
     }
     
     err = e.uint64(count)
     if err != nil {
     	return err
     }
     
     err = e.Flush()
     if err != nil {
     	return err
     }
     return err
}

func (d *Decoder) HandleMyRpc(e *Encoder) (error os.Error){
     var retValue MyRpcProcedure
     d.ReadAll()
     methodId, err := d.uint64()
     if err != nil {
     	return err		
     }
     switch *methodId{
     	    
	    case methodIdMyRpcIncrement:
	    	 /* FIXME: Temporarily place reset here. We also reset in ReadAll calls. This 
		  *        should probably go in one place: each type decoder, but we need
		  *        to be able to differentiate between an application-called decode
		  *        and a decode of internal elements. The latter case should not 
		  *        call reset. */
	    	 d.reset()
	    	 
		
		
		retValue = _fp_myRpcIncrement()
		
		
	    
	    case methodIdMyRpcIncrementReply:
	    	 /* FIXME: Temporarily place reset here. We also reset in ReadAll calls. This 
		  *        should probably go in one place: each type decoder, but we need
		  *        to be able to differentiate between an application-called decode
		  *        and a decode of internal elements. The latter case should not 
		  *        call reset. */
	    	 d.reset()
	    	 
		
		count, err0 := d.uint64()
		if err0 != nil {
		   return err0
		}
		
		
		retValue = _fp_myRpcIncrementReply(*count)
		
		
	    
	    default:
	    	 e := fmt.Errorf("Wrong MethodID")
		 return e
     }

     return e.MyRpcProcedure(retValue)
    
}

func BufferHandleMyRpc(bufReader *bytes.Buffer, fd syscall.Fd) (error os.Error) {
     var retValue MyRpcProcedure
     d := NewDecoder(bufReader)
     writer := goodmiddleman.NewWriter(fd)
     e := NewEncoder(writer)

     methodId, err := d.uint64()
     if err != nil {
     	return err	
     }

     switch *methodId{
     	    
	    case methodIdMyRpcIncrement:
	    	 /* FIXME: Temporarily place reset here. We also reset in ReadAll calls. This 
		  *        should probably go in one place: each type decoder, but we need
		  *        to be able to differentiate between an application-called decode
		  *        and a decode of internal elements. The latter case should not 
		  *        call reset. */
	    	 d.reset()
	    	 
		
		
		retValue = _fp_myRpcIncrement()
		
		
	    
	    case methodIdMyRpcIncrementReply:
	    	 /* FIXME: Temporarily place reset here. We also reset in ReadAll calls. This 
		  *        should probably go in one place: each type decoder, but we need
		  *        to be able to differentiate between an application-called decode
		  *        and a decode of internal elements. The latter case should not 
		  *        call reset. */
	    	 d.reset()
	    	 
		
		count, err0 := d.uint64()
		if err0 != nil {
		   return err0
		}
		
		
		retValue = _fp_myRpcIncrementReply(*count)
		
		
	    
	    default:
	    	 e := fmt.Errorf("Wrong MethodID")
		 return  e
     }

     return e.MyRpcProcedure(retValue)
}

func (t *MyRpc) Handle(fd syscall.Fd) (syscall.Status) {
	e := NewEncoder(goodmiddleman.NewWriter(fd))
	d := NewDecoder(goodmiddleman.NewReader(fd))
	err := d.HandleMyRpc(e)
	if err != nil {
		return syscall.StatusFail
	}

	return syscall.StatusOk
}

func (t *MyRpc) RpcReadBuffer(buffer []byte) (defined.Rpc, syscall.Status) {
     d := NewDecoder(bytes.NewBuffer(buffer))
     d.ReadAll()
     methodId, err := d.uint64()
     if err != nil {
     	return nil, syscall.StatusFail
     }
     switch *methodId{
     	    
	    case methodIdMyRpcIncrement:
	    	 /* FIXME: Temporarily place reset here. We also reset in ReadAll calls. This 
		  *        should probably go in one place: each type decoder, but we need
		  *        to be able to differentiate between an application-called decode
		  *        and a decode of internal elements. The latter case should not 
		  *        call reset. */
	    	 d.reset()
	    	 
		
		
		return &MyRpcIncrement{  }, syscall.StatusOk
	    
	    case methodIdMyRpcIncrementReply:
	    	 /* FIXME: Temporarily place reset here. We also reset in ReadAll calls. This 
		  *        should probably go in one place: each type decoder, but we need
		  *        to be able to differentiate between an application-called decode
		  *        and a decode of internal elements. The latter case should not 
		  *        call reset. */
	    	 d.reset()
	    	 
		
		Arg0, err0 := d.uint64()
		if err0 != nil {
		   return nil, syscall.StatusFail
		}
		
		
		return &MyRpcIncrementReply{ *Arg0,  }, syscall.StatusOk
	    
	    default:
		 return nil, syscall.StatusFail
     }

	return nil, syscall.StatusFail
}




func (t *MyRpcIncrement) Handle(fd syscall.Fd) (syscall.Status) {
	e := NewEncoder(goodmiddleman.NewWriter(fd))
	d := NewDecoder(goodmiddleman.NewReader(fd))
	err := d.HandleMyRpc(e)
	if err != nil {
		return syscall.StatusFail
	}

	return syscall.StatusOk
}

func (t *MyRpcIncrement) WriteBuffer() ([]byte, syscall.Status) {
	var buffer bytes.Buffer
	e := NewEncoder(&buffer)
	err := e.MyRpcIncrement()
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	return buffer.Bytes(), syscall.StatusOk
}

func (t *MyRpcIncrement) read(d *Decoder) (*MyRpcIncrement, syscall.Status){
	var err os.Error
	var value MyRpcIncrement
	d.reset()
	methodId, err := d.uint64()
	if err != nil {
		return nil, syscall.StatusFail
	}

	if *methodId != methodIdMyRpcIncrement {
		return nil, syscall.StatusFail
	}

	
	return &value, syscall.StatusOk
}


func (t *MyRpcIncrement) ReadBuffer(buffer []byte) (syscall.Status) {
	d := NewDecoder(bytes.NewBuffer(buffer))
	value, status := t.read(d)
	if status != syscall.StatusOk {
		return status
	}

	*t = *value
	return syscall.StatusOk
}

func (t *MyRpcIncrement) GetHash() (syscall.HashValue) {
       return syscall.HashValue{ 0xcd,0x79,0x0a,0x94,0xd5,0x76,0xa6,0x5c,0x45,0x89,0x67,0x08,0x2e,0xb4,0xc5,0x90,0x31,0xc9,0xef,0x2e,0x54,0xed,0xf3,0x93,0x11,0x30,0x68,0x49,0xac,0x22,0x47,0x61,0x6f,0x86,0xba,0x44,0x35,0xa5,0x95,0x12,0x30,0xe4,0xd9,0x7f,0x68,0xd4,0x89,0x9a,0x78,0x2a,0x76,0x64,0x14,0x8e,0x48,0xc1,0x63,0xac,0x06,0x0a,0xcc,0x04,0xbf,0x37, }
}




func (t *MyRpcIncrementReply) Handle(fd syscall.Fd) (syscall.Status) {
	e := NewEncoder(goodmiddleman.NewWriter(fd))
	d := NewDecoder(goodmiddleman.NewReader(fd))
	err := d.HandleMyRpc(e)
	if err != nil {
		return syscall.StatusFail
	}

	return syscall.StatusOk
}

func (t *MyRpcIncrementReply) WriteBuffer() ([]byte, syscall.Status) {
	var buffer bytes.Buffer
	e := NewEncoder(&buffer)
	err := e.MyRpcIncrementReply(t.Var0, )
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	return buffer.Bytes(), syscall.StatusOk
}

func (t *MyRpcIncrementReply) read(d *Decoder) (*MyRpcIncrementReply, syscall.Status){
	var err os.Error
	var value MyRpcIncrementReply
	d.reset()
	methodId, err := d.uint64()
	if err != nil {
		return nil, syscall.StatusFail
	}

	if *methodId != methodIdMyRpcIncrementReply {
		return nil, syscall.StatusFail
	}

	
	Var0, err := d.uint64()
	if err != nil {
		return nil, syscall.StatusFail
	}
	value.Var0 = *Var0
 	
	return &value, syscall.StatusOk
}


func (t *MyRpcIncrementReply) ReadBuffer(buffer []byte) (syscall.Status) {
	d := NewDecoder(bytes.NewBuffer(buffer))
	value, status := t.read(d)
	if status != syscall.StatusOk {
		return status
	}

	*t = *value
	return syscall.StatusOk
}

func (t *MyRpcIncrementReply) GetHash() (syscall.HashValue) {
       return syscall.HashValue{ 0x5e,0xbc,0x47,0x5c,0xfd,0x9b,0x93,0xfc,0xe1,0x47,0xd9,0xed,0x66,0x07,0x28,0xf0,0x7f,0x18,0xf9,0xfd,0x0c,0xb6,0xcf,0x13,0x2a,0xa7,0xd0,0xdd,0xf0,0xd8,0xf6,0xe7,0xc0,0x88,0x45,0xfa,0x2d,0x03,0xf1,0x14,0xda,0xff,0xbe,0x55,0x71,0xcf,0x49,0x79,0xd6,0x82,0x6f,0xc7,0x52,0x36,0x24,0x5b,0x39,0xbf,0xad,0x08,0xdd,0x23,0xea,0x62, }
}



type MyRpcProcedure interface {
	//These interfaces are used to differ several rpc interfaces in one package
	//The compiler will complain if a rpc function returns a procedure from another
	//rpc interface
	GetHash() syscall.HashValue
	WriteBuffer()             ([]byte, syscall.Status)
	ReadBuffer(buffer []byte) (syscall.Status)
	Invoke()                  defined.Rpc
	GetInterface()            defined.RpcInterface
	MyRpcProcedure()
}

type MyRpc struct {
}



type MyRpcIncrement struct {
	
}

func (t *MyRpcIncrement) MyRpcProcedure() {
	//oh look its nothing
}

func _default_myRpcIncrement() (MyRpcProcedure) {
	panic("myRpcIncrement not implemented")
	return nil
}

var _fp_myRpcIncrement func()(MyRpcProcedure) = _default_myRpcIncrement


func SetupMyRpcIncrement (fn func()(MyRpcProcedure)) {
	_fp_myRpcIncrement = fn
}

func (t *MyRpcIncrement) Invoke() defined.Rpc {
	return _fp_myRpcIncrement()
}

func (t *MyRpcIncrement) GetInterface() defined.RpcInterface {
	return &MyRpc{}
}


type MyRpcIncrementReply struct {
	 Var0 uint64
	
}

func (t *MyRpcIncrementReply) MyRpcProcedure() {
	//oh look its nothing
}

func _default_myRpcIncrementReply( Var0 uint64, ) (MyRpcProcedure) {
	panic("myRpcIncrementReply not implemented")
	return nil
}

var _fp_myRpcIncrementReply func( uint64,)(MyRpcProcedure) = _default_myRpcIncrementReply


func SetupMyRpcIncrementReply (fn func( uint64,)(MyRpcProcedure)) {
	_fp_myRpcIncrementReply = fn
}

func (t *MyRpcIncrementReply) Invoke() defined.Rpc {
	return _fp_myRpcIncrementReply( t.Var0, )
}

func (t *MyRpcIncrementReply) GetInterface() defined.RpcInterface {
	return &MyRpc{}
}



func InterfaceHandleMyRpc(params []interface{}) (error os.Error){
     var retValue MyRpcProcedure
     e := params[0].(*Encoder)
     params = params[1:]
     methodId := params[0].(uint64)
     params = params[1:]
     switch methodId {
     	    
	    case methodIdMyRpcIncrement:
	    	 
			
			     retValue = _fp_myRpcIncrement()
		 	
	 	 
	    
	    case methodIdMyRpcIncrementReply:
	    	 
			
			     retValue = _fp_myRpcIncrementReply(*(params[0].(*uint64)), )
		 	
	 	 
	    
	    default:
	    	 e := fmt.Errorf("Wrong MethodID")
		 return e
     }
     return e.MyRpcProcedure(retValue)
}

func (e *Encoder) MyRpcProcedure(retValue MyRpcProcedure) (os.Error) {
    if retValue == nil {
        return nil
    }

    switch retValue.(type) {

        case *MyRpcIncrement:
             
             err := e.MyRpcIncrement()
             if err != nil {
                  return err
             }
             return e.Flush()

        case *MyRpcIncrementReply:
             
             t := retValue.(*MyRpcIncrementReply)
             
             err := e.MyRpcIncrementReply(t.Var0, )
             if err != nil {
                  return err
             }
             return e.Flush()

       default:
	 return fmt.Errorf("Invalid Type in return value")
    }

   return nil
}
func DecodeMyRpc(decoder interface{}) (params []interface{}, err os.Error) {
     d := decoder.(*Decoder)
     d.ReadAll()
     methodId, err := d.uint64()
     if err != nil {
     	return []interface{}{}, err		
     }

     params = append(params, *methodId)
     switch *methodId {
     	
     	  case methodIdMyRpcIncrement:
               d.reset()
     	       
     	
     	  case methodIdMyRpcIncrementReply:
               d.reset()
     	       
     	       count, err0 := d.uint64()
               if err0 != nil {
	       	  return []interface{}{}, err0
     	       }
     	       params = append(params, count)
     	       
          
         default:
		e := fmt.Errorf("Wrong MethodID")
		return []interface{}{}, e
     }    
     return params, nil
}
func (e *Encoder) Any(a Any) (err os.Error){
     switch a.Value.(type) {
     
     case nil:
     	err = e.SliceOfBytes([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0})
	if err != nil {
	   return err
	}
	err = e.uint8(pNIL)
	if err != nil {
	   return err
	}
     case int8:
     	err = e.SliceOfBytes([]byte{0xc2, 0x71, 0x6e, 0x3c, 0x34, 0x13, 0xc0, 0xbe, 0xb3, 0x9e, 0x2e, 0xbc, 0xc7, 0x99, 0x62, 0x3f, 0x28, 0xe9, 0x9d, 0x19, 0x71, 0x6a, 0x0, 0x5b, 0x69, 0x4b, 0x1c, 0xbb, 0x3d, 0x8d, 0xcc, 0x45, 0xbd, 0x51, 0xca, 0x50, 0xc7, 0x3f, 0x8a, 0x64, 0xc8, 0xa0, 0xf0, 0xb, 0x46, 0x9a, 0x87, 0x5, 0xe9, 0x3c, 0xb9, 0x27, 0x91, 0xdf, 0x95, 0x88, 0x1b, 0x2e, 0xfa, 0x9f, 0xc0, 0x1f, 0xcb, 0xad}) 
	if err != nil {
	   return err
	}
	t := a.Value.(int8)
	err = e.int8(t)
	if err != nil {
	   return err
	}
     case uint8:
     	err = e.SliceOfBytes([]byte{0x9, 0x66, 0x78, 0xbb, 0x4a, 0x86, 0x63, 0x8d, 0x8e, 0xc6, 0x58, 0x8e, 0xcc, 0x2d, 0x89, 0x5a, 0x5c, 0x17, 0xb4, 0x86, 0x37, 0x8c, 0x81, 0xc2, 0xf2, 0xac, 0xf2, 0x48, 0x67, 0x57, 0x82, 0x13, 0x3e, 0x2e, 0x7d, 0x80, 0xb6, 0x66, 0x8d, 0x84, 0xc4, 0x55, 0xf4, 0xc9, 0xe1, 0x33, 0xfc, 0x71, 0xb, 0x77, 0x43, 0x63, 0x6, 0x82, 0x76, 0x63, 0x7, 0xbc, 0xf1, 0x64, 0xdb, 0xd9, 0x5c, 0x93})
	if err != nil {
	   return err
	}
	t := a.Value.(uint8)
	err = e.uint8(t)
	if err != nil {
	   return err
	}
     case int16:
     	err = e.SliceOfBytes([]byte{0x99, 0x7f, 0x69, 0x9c, 0x17, 0xfd, 0x6, 0x74, 0x8c, 0x2d, 0xba, 0xc4, 0x61, 0x1, 0x35, 0x21, 0xf1, 0x97, 0xd8, 0x1e, 0x74, 0x3c, 0x2f, 0x96, 0x56, 0xe6, 0xdc, 0xfc, 0x14, 0x1e, 0xd, 0x83, 0x36, 0xdc, 0x73, 0x36, 0xb0, 0xf4, 0x9e, 0x40, 0x2b, 0xfe, 0x97, 0x6f, 0xfa, 0xa5, 0x27, 0xac, 0xe1, 0xa2, 0x57, 0x2a, 0xae, 0x6d, 0x18, 0x22, 0xe2, 0xdc, 0xd8, 0x79, 0xe0, 0xb6, 0xf6, 0x7e})
	if err != nil {
	   return err
	}
	t := a.Value.(int16)
	err = e.int16(t)
	if err != nil {
	   return err
	}
     case uint16:
     	err = e.SliceOfBytes([]byte{0xa9, 0x1f, 0x92, 0xf4, 0xe9, 0x96, 0xb6, 0xd4, 0xa4, 0xcb, 0x85, 0x8d, 0x11, 0x80, 0x20, 0x10, 0xd6, 0x29, 0xba, 0x29, 0xe1, 0x89, 0x50, 0x2c, 0xa0, 0xf2, 0xcb, 0x1d, 0x86, 0xb8, 0x27, 0x3b, 0x67, 0xf3, 0x35, 0x72, 0xd1, 0x78, 0x15, 0xcc, 0xb0, 0x94, 0x94, 0x6f, 0x2, 0xab, 0x2e, 0x46, 0xcd, 0x74, 0xea, 0xf5, 0x15, 0xa, 0x26, 0xdc, 0x4e, 0xf7, 0xd, 0x9f, 0x3a, 0x9c, 0x6e, 0x55})
	if err != nil {
	   return err
	}
	t := a.Value.(uint16)
	err = e.uint16(t)
	if err != nil {
	   return err
	}
     case int32:
     	err = e.SliceOfBytes([]byte{0xeb, 0xc1, 0x67, 0x8b, 0x6, 0x82, 0x70, 0x21, 0x38, 0xc2, 0xd9, 0x9e, 0x33, 0x22, 0xd1, 0xa8, 0xc7, 0x2e, 0x9b, 0x68, 0xe9, 0x41, 0x12, 0x0, 0x1e, 0x3e, 0x51, 0xa8, 0xf5, 0xd9, 0xfa, 0x34, 0xc, 0x44, 0x9c, 0x6, 0x6d, 0x9d, 0x4c, 0xe7, 0x2a, 0x6, 0xab, 0x75, 0x77, 0x5d, 0xdf, 0x28, 0x34, 0x88, 0x7c, 0x7e, 0x96, 0x97, 0xbb, 0x8a, 0x95, 0xfe, 0x7, 0x65, 0xf7, 0x7c, 0x7e, 0x4c})
	if err != nil {
	   return err
	}
	t := a.Value.(int32)
	err = e.int32(t)
	if err != nil {
	   return err
	}
     case uint32:
     	err = e.SliceOfBytes([]byte{0xce, 0xf4, 0x3a, 0x5, 0xae, 0x67, 0xd9, 0x73, 0xc2, 0xa2, 0x1d, 0xf8, 0xcd, 0xf9, 0xd2, 0xde, 0x69, 0x8d, 0xd, 0xb7, 0x61, 0xb9, 0x51, 0x22, 0x58, 0xed, 0x8f, 0xb1, 0x83, 0xf1, 0x5c, 0xff, 0x5b, 0x84, 0xe2, 0x14, 0xe, 0x10, 0x68, 0x3f, 0x7a, 0xd9, 0xa7, 0x8f, 0x5b, 0xe4, 0x9e, 0x4e, 0x0, 0x7d, 0xcb, 0xfb, 0xd1, 0x69, 0x59, 0x9d, 0xbf, 0x9b, 0x75, 0x65, 0x15, 0x9e, 0x8b, 0x82})
	if err != nil {
	   return err
	}
	t := a.Value.(uint32)
	err = e.uint32(t)
	if err != nil {
	   return err
	}
     case int64:
     	err = e.SliceOfBytes([]byte{0x56, 0x16, 0x70, 0x35, 0xd0, 0x9, 0x18, 0x69, 0xe, 0xae, 0xad, 0x60, 0xd1, 0xee, 0x39, 0xa8, 0x61, 0x45, 0x58, 0x5b, 0x99, 0x20, 0x94, 0x57, 0x1f, 0xb0, 0x48, 0xeb, 0xb2, 0xcf, 0x5c, 0xa5, 0x8d, 0xc7, 0x8e, 0x7e, 0x3c, 0x89, 0xcd, 0x2f, 0xdc, 0xf2, 0x1c, 0x2a, 0xe3, 0xd2, 0x7f, 0x98, 0xc2, 0xad, 0x1c, 0x3d, 0x4e, 0x62, 0xd9, 0xdb, 0xc8, 0xc8, 0x59, 0xc5, 0xd5, 0xc6, 0xed, 0x7a})
	if err != nil {
	   return err
	}
	t := a.Value.(int64)
	err = e.int64(t)
	if err != nil {
	   return err
	}
     case uint64:
     	err = e.SliceOfBytes([]byte{0x11, 0x26, 0xb3, 0xd, 0x51, 0x59, 0x87, 0x5e, 0xd, 0x5b, 0x93, 0xfc, 0x92, 0xf0, 0x78, 0xaa, 0x12, 0xac, 0x93, 0xb8, 0x30, 0x1f, 0x48, 0xe, 0x13, 0x4d, 0x8b, 0xfb, 0x4c, 0x58, 0xfa, 0x3a, 0x69, 0x6a, 0x81, 0x1, 0xc5, 0x47, 0xc1, 0x55, 0x43, 0x95, 0x41, 0xdf, 0x3c, 0x8e, 0xb6, 0x96, 0x4a, 0x3c, 0x88, 0xab, 0x3f, 0x88, 0xed, 0x37, 0x5f, 0x8, 0x4a, 0x41, 0x8e, 0xd5, 0xda, 0x1e})
	if err != nil {
	   return err
	}
	t := a.Value.(uint64)
	err = e.uint64(t)
	if err != nil {
	   return err
	}
     case float32:
     	err = e.SliceOfBytes([]byte{0x42, 0x36, 0xae, 0xd3, 0x62, 0xca, 0x34, 0x75, 0x94, 0x52, 0xf0, 0x5f, 0x44, 0x83, 0x61, 0x75, 0x69, 0x39, 0xcf, 0x69, 0x74, 0x91, 0xee, 0x8d, 0x35, 0x8c, 0xd7, 0xa1, 0x63, 0xf, 0x88, 0x86, 0x6b, 0x52, 0xdd, 0x6d, 0xe1, 0xb2, 0x26, 0xf4, 0x3a, 0x9c, 0x9e, 0xf1, 0x56, 0xd, 0xf1, 0x48, 0x7, 0x39, 0x46, 0xf8, 0xe9, 0xd3, 0xab, 0x86, 0xe0, 0x1c, 0x98, 0xd, 0x17, 0x6b, 0x2, 0x63})
	if err != nil {
	   return err
	}
	t := a.Value.(float32)
	err = e.float32(t)
	if err != nil {
	   return err
	}
     case float64:
     	err = e.SliceOfBytes([]byte{0x65, 0x9b, 0xb2, 0x59, 0x85, 0xe2, 0x60, 0xe7, 0x1e, 0x12, 0x17, 0x3f, 0xc3, 0x1f, 0x20, 0x45, 0x8, 0x9e, 0x7e, 0x11, 0x6b, 0xaa, 0xb3, 0x1e, 0x6d, 0x7d, 0x7a, 0x5b, 0xe3, 0x3d, 0x40, 0xb5, 0x40, 0x6, 0x52, 0x85, 0x37, 0x80, 0x2c, 0xd8, 0x7d, 0x48, 0x67, 0xe3, 0x9a, 0xdd, 0xc9, 0x13, 0x11, 0x2c, 0xa5, 0xcc, 0x5a, 0x33, 0xbc, 0x35, 0x6b, 0x3e, 0xa8, 0x75, 0x93, 0x84, 0xcf, 0x1b})
	if err != nil {
	   return err
	}
	t := a.Value.(float64)
	err = e.float64(t)
	if err != nil {
	   return err
	}
     case bool:
     	err = e.SliceOfBytes([]byte{0x3e, 0x76, 0x6, 0x81, 0x73, 0x27, 0x61, 0xed, 0x16, 0x8e, 0xa3, 0x8, 0xe1, 0x10, 0x11, 0x85, 0xe1, 0xbd, 0x39, 0x2, 0xee, 0x67, 0x60, 0x21, 0x6a, 0x59, 0xc4, 0x7, 0x5a, 0x99, 0xc1, 0x46, 0xb7, 0xcd, 0x98, 0x14, 0xce, 0x14, 0x47, 0xe, 0xb0, 0x80, 0x6d, 0x91, 0x66, 0x50, 0xb0, 0xe5, 0xe, 0x77, 0x6f, 0x53, 0xe5, 0xd1, 0x72, 0x28, 0x1d, 0xd0, 0xe1, 0x70, 0x43, 0xc8, 0x65, 0x39})
	if err != nil {
	   return err
	}
	t := a.Value.(bool)
	err = e.bool(t)
	if err != nil {
	   return err
	}
     case string:
     	err = e.SliceOfBytes([]byte{0x27, 0x57, 0xcb, 0x3c, 0xaf, 0xc3, 0x9a, 0xf4, 0x51, 0xab, 0xb2, 0x69, 0x7b, 0xe7, 0x9b, 0x4a, 0xb6, 0x1d, 0x63, 0xd7, 0x4d, 0x85, 0xb0, 0x41, 0x86, 0x29, 0xde, 0x8c, 0x26, 0x81, 0x1b, 0x52, 0x9f, 0x3f, 0x37, 0x80, 0xd0, 0x15, 0x0, 0x63, 0xff, 0x55, 0xa2, 0xbe, 0xee, 0x74, 0xc4, 0xec, 0x10, 0x2a, 0x2a, 0x27, 0x31, 0xa1, 0xf1, 0xf7, 0xf1, 0xd, 0x47, 0x3a, 0xd1, 0x8a, 0x6a, 0x87})
	if err != nil {
	   return err
	}
	t := a.Value.(string)
	err = e.string(t)
	if err != nil {
	   return err
	}
     default:
	v := reflect.ValueOf(a)
     	e := fmt.Errorf("Wrong type used as Any " + v.Type().Name())
	return e
     }
     return nil
}

func (e *Encoder) AnyInternal(a Any) (err os.Error){
     switch a.Value.(type) {
     
     case nil:
     	err = e.SliceOfBytes([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0})
	if err != nil {
	   return err
	}
	err = e.uint8(pNIL)
	if err != nil {
	   return err
	}
     case int8:
     	err = e.SliceOfBytes([]byte{0xc2, 0x71, 0x6e, 0x3c, 0x34, 0x13, 0xc0, 0xbe, 0xb3, 0x9e, 0x2e, 0xbc, 0xc7, 0x99, 0x62, 0x3f, 0x28, 0xe9, 0x9d, 0x19, 0x71, 0x6a, 0x0, 0x5b, 0x69, 0x4b, 0x1c, 0xbb, 0x3d, 0x8d, 0xcc, 0x45, 0xbd, 0x51, 0xca, 0x50, 0xc7, 0x3f, 0x8a, 0x64, 0xc8, 0xa0, 0xf0, 0xb, 0x46, 0x9a, 0x87, 0x5, 0xe9, 0x3c, 0xb9, 0x27, 0x91, 0xdf, 0x95, 0x88, 0x1b, 0x2e, 0xfa, 0x9f, 0xc0, 0x1f, 0xcb, 0xad}) 
	if err != nil {
	   return err
	}
	t := a.Value.(int8)
	err = e.int8(t)
	if err != nil {
	   return err
	}
     case uint8:
     	err = e.SliceOfBytes([]byte{0x9, 0x66, 0x78, 0xbb, 0x4a, 0x86, 0x63, 0x8d, 0x8e, 0xc6, 0x58, 0x8e, 0xcc, 0x2d, 0x89, 0x5a, 0x5c, 0x17, 0xb4, 0x86, 0x37, 0x8c, 0x81, 0xc2, 0xf2, 0xac, 0xf2, 0x48, 0x67, 0x57, 0x82, 0x13, 0x3e, 0x2e, 0x7d, 0x80, 0xb6, 0x66, 0x8d, 0x84, 0xc4, 0x55, 0xf4, 0xc9, 0xe1, 0x33, 0xfc, 0x71, 0xb, 0x77, 0x43, 0x63, 0x6, 0x82, 0x76, 0x63, 0x7, 0xbc, 0xf1, 0x64, 0xdb, 0xd9, 0x5c, 0x93})
	if err != nil {
	   return err
	}
	t := a.Value.(uint8)
	err = e.uint8(t)
	if err != nil {
	   return err
	}
     case int16:
     	err = e.SliceOfBytes([]byte{0x99, 0x7f, 0x69, 0x9c, 0x17, 0xfd, 0x6, 0x74, 0x8c, 0x2d, 0xba, 0xc4, 0x61, 0x1, 0x35, 0x21, 0xf1, 0x97, 0xd8, 0x1e, 0x74, 0x3c, 0x2f, 0x96, 0x56, 0xe6, 0xdc, 0xfc, 0x14, 0x1e, 0xd, 0x83, 0x36, 0xdc, 0x73, 0x36, 0xb0, 0xf4, 0x9e, 0x40, 0x2b, 0xfe, 0x97, 0x6f, 0xfa, 0xa5, 0x27, 0xac, 0xe1, 0xa2, 0x57, 0x2a, 0xae, 0x6d, 0x18, 0x22, 0xe2, 0xdc, 0xd8, 0x79, 0xe0, 0xb6, 0xf6, 0x7e})
	if err != nil {
	   return err
	}
	t := a.Value.(int16)
	err = e.int16(t)
	if err != nil {
	   return err
	}
     case uint16:
     	err = e.SliceOfBytes([]byte{0xa9, 0x1f, 0x92, 0xf4, 0xe9, 0x96, 0xb6, 0xd4, 0xa4, 0xcb, 0x85, 0x8d, 0x11, 0x80, 0x20, 0x10, 0xd6, 0x29, 0xba, 0x29, 0xe1, 0x89, 0x50, 0x2c, 0xa0, 0xf2, 0xcb, 0x1d, 0x86, 0xb8, 0x27, 0x3b, 0x67, 0xf3, 0x35, 0x72, 0xd1, 0x78, 0x15, 0xcc, 0xb0, 0x94, 0x94, 0x6f, 0x2, 0xab, 0x2e, 0x46, 0xcd, 0x74, 0xea, 0xf5, 0x15, 0xa, 0x26, 0xdc, 0x4e, 0xf7, 0xd, 0x9f, 0x3a, 0x9c, 0x6e, 0x55})
	if err != nil {
	   return err
	}
	t := a.Value.(uint16)
	err = e.uint16(t)
	if err != nil {
	   return err
	}
     case int32:
     	err = e.SliceOfBytes([]byte{0xeb, 0xc1, 0x67, 0x8b, 0x6, 0x82, 0x70, 0x21, 0x38, 0xc2, 0xd9, 0x9e, 0x33, 0x22, 0xd1, 0xa8, 0xc7, 0x2e, 0x9b, 0x68, 0xe9, 0x41, 0x12, 0x0, 0x1e, 0x3e, 0x51, 0xa8, 0xf5, 0xd9, 0xfa, 0x34, 0xc, 0x44, 0x9c, 0x6, 0x6d, 0x9d, 0x4c, 0xe7, 0x2a, 0x6, 0xab, 0x75, 0x77, 0x5d, 0xdf, 0x28, 0x34, 0x88, 0x7c, 0x7e, 0x96, 0x97, 0xbb, 0x8a, 0x95, 0xfe, 0x7, 0x65, 0xf7, 0x7c, 0x7e, 0x4c})
	if err != nil {
	   return err
	}
	t := a.Value.(int32)
	err = e.int32(t)
	if err != nil {
	   return err
	}
     case uint32:
     	err = e.SliceOfBytes([]byte{0xce, 0xf4, 0x3a, 0x5, 0xae, 0x67, 0xd9, 0x73, 0xc2, 0xa2, 0x1d, 0xf8, 0xcd, 0xf9, 0xd2, 0xde, 0x69, 0x8d, 0xd, 0xb7, 0x61, 0xb9, 0x51, 0x22, 0x58, 0xed, 0x8f, 0xb1, 0x83, 0xf1, 0x5c, 0xff, 0x5b, 0x84, 0xe2, 0x14, 0xe, 0x10, 0x68, 0x3f, 0x7a, 0xd9, 0xa7, 0x8f, 0x5b, 0xe4, 0x9e, 0x4e, 0x0, 0x7d, 0xcb, 0xfb, 0xd1, 0x69, 0x59, 0x9d, 0xbf, 0x9b, 0x75, 0x65, 0x15, 0x9e, 0x8b, 0x82})
	if err != nil {
	   return err
	}
	t := a.Value.(uint32)
	err = e.uint32(t)
	if err != nil {
	   return err
	}
     case int64:
     	err = e.SliceOfBytes([]byte{0x56, 0x16, 0x70, 0x35, 0xd0, 0x9, 0x18, 0x69, 0xe, 0xae, 0xad, 0x60, 0xd1, 0xee, 0x39, 0xa8, 0x61, 0x45, 0x58, 0x5b, 0x99, 0x20, 0x94, 0x57, 0x1f, 0xb0, 0x48, 0xeb, 0xb2, 0xcf, 0x5c, 0xa5, 0x8d, 0xc7, 0x8e, 0x7e, 0x3c, 0x89, 0xcd, 0x2f, 0xdc, 0xf2, 0x1c, 0x2a, 0xe3, 0xd2, 0x7f, 0x98, 0xc2, 0xad, 0x1c, 0x3d, 0x4e, 0x62, 0xd9, 0xdb, 0xc8, 0xc8, 0x59, 0xc5, 0xd5, 0xc6, 0xed, 0x7a})
	if err != nil {
	   return err
	}
	t := a.Value.(int64)
	err = e.int64(t)
	if err != nil {
	   return err
	}
     case uint64:
     	err = e.SliceOfBytes([]byte{0x11, 0x26, 0xb3, 0xd, 0x51, 0x59, 0x87, 0x5e, 0xd, 0x5b, 0x93, 0xfc, 0x92, 0xf0, 0x78, 0xaa, 0x12, 0xac, 0x93, 0xb8, 0x30, 0x1f, 0x48, 0xe, 0x13, 0x4d, 0x8b, 0xfb, 0x4c, 0x58, 0xfa, 0x3a, 0x69, 0x6a, 0x81, 0x1, 0xc5, 0x47, 0xc1, 0x55, 0x43, 0x95, 0x41, 0xdf, 0x3c, 0x8e, 0xb6, 0x96, 0x4a, 0x3c, 0x88, 0xab, 0x3f, 0x88, 0xed, 0x37, 0x5f, 0x8, 0x4a, 0x41, 0x8e, 0xd5, 0xda, 0x1e})
	if err != nil {
	   return err
	}
	t := a.Value.(uint64)
	err = e.uint64(t)
	if err != nil {
	   return err
	}
     case float32:
     	err = e.SliceOfBytes([]byte{0x42, 0x36, 0xae, 0xd3, 0x62, 0xca, 0x34, 0x75, 0x94, 0x52, 0xf0, 0x5f, 0x44, 0x83, 0x61, 0x75, 0x69, 0x39, 0xcf, 0x69, 0x74, 0x91, 0xee, 0x8d, 0x35, 0x8c, 0xd7, 0xa1, 0x63, 0xf, 0x88, 0x86, 0x6b, 0x52, 0xdd, 0x6d, 0xe1, 0xb2, 0x26, 0xf4, 0x3a, 0x9c, 0x9e, 0xf1, 0x56, 0xd, 0xf1, 0x48, 0x7, 0x39, 0x46, 0xf8, 0xe9, 0xd3, 0xab, 0x86, 0xe0, 0x1c, 0x98, 0xd, 0x17, 0x6b, 0x2, 0x63})
	if err != nil {
	   return err
	}
	t := a.Value.(float32)
	err = e.float32(t)
	if err != nil {
	   return err
	}
     case float64:
     	err = e.SliceOfBytes([]byte{0x65, 0x9b, 0xb2, 0x59, 0x85, 0xe2, 0x60, 0xe7, 0x1e, 0x12, 0x17, 0x3f, 0xc3, 0x1f, 0x20, 0x45, 0x8, 0x9e, 0x7e, 0x11, 0x6b, 0xaa, 0xb3, 0x1e, 0x6d, 0x7d, 0x7a, 0x5b, 0xe3, 0x3d, 0x40, 0xb5, 0x40, 0x6, 0x52, 0x85, 0x37, 0x80, 0x2c, 0xd8, 0x7d, 0x48, 0x67, 0xe3, 0x9a, 0xdd, 0xc9, 0x13, 0x11, 0x2c, 0xa5, 0xcc, 0x5a, 0x33, 0xbc, 0x35, 0x6b, 0x3e, 0xa8, 0x75, 0x93, 0x84, 0xcf, 0x1b})
	if err != nil {
	   return err
	}
	t := a.Value.(float64)
	err = e.float64(t)
	if err != nil {
	   return err
	}
     case bool:
     	err = e.SliceOfBytes([]byte{0x3e, 0x76, 0x6, 0x81, 0x73, 0x27, 0x61, 0xed, 0x16, 0x8e, 0xa3, 0x8, 0xe1, 0x10, 0x11, 0x85, 0xe1, 0xbd, 0x39, 0x2, 0xee, 0x67, 0x60, 0x21, 0x6a, 0x59, 0xc4, 0x7, 0x5a, 0x99, 0xc1, 0x46, 0xb7, 0xcd, 0x98, 0x14, 0xce, 0x14, 0x47, 0xe, 0xb0, 0x80, 0x6d, 0x91, 0x66, 0x50, 0xb0, 0xe5, 0xe, 0x77, 0x6f, 0x53, 0xe5, 0xd1, 0x72, 0x28, 0x1d, 0xd0, 0xe1, 0x70, 0x43, 0xc8, 0x65, 0x39})
	if err != nil {
	   return err
	}
	t := a.Value.(bool)
	err = e.bool(t)
	if err != nil {
	   return err
	}
     case string:
     	err = e.SliceOfBytes([]byte{0x27, 0x57, 0xcb, 0x3c, 0xaf, 0xc3, 0x9a, 0xf4, 0x51, 0xab, 0xb2, 0x69, 0x7b, 0xe7, 0x9b, 0x4a, 0xb6, 0x1d, 0x63, 0xd7, 0x4d, 0x85, 0xb0, 0x41, 0x86, 0x29, 0xde, 0x8c, 0x26, 0x81, 0x1b, 0x52, 0x9f, 0x3f, 0x37, 0x80, 0xd0, 0x15, 0x0, 0x63, 0xff, 0x55, 0xa2, 0xbe, 0xee, 0x74, 0xc4, 0xec, 0x10, 0x2a, 0x2a, 0x27, 0x31, 0xa1, 0xf1, 0xf7, 0xf1, 0xd, 0x47, 0x3a, 0xd1, 0x8a, 0x6a, 0x87})
	if err != nil {
	   return err
	}
	t := a.Value.(string)
	err = e.string(t)
	if err != nil {
	   return err
	}
     default:
	v := reflect.ValueOf(a)
	e := fmt.Errorf("Wrong type used as Any " + v.Type().Name())
	return e
     }
     return nil
}
func (d *Decoder) Any() (retValue *Any, error os.Error) {
     l, err := d.uint32()
     if err != nil {
     	return nil, err
     }
     hashValue := make([]byte, *l)
     err = d.SliceOfBytes(hashValue, *l)
     if err != nil {
     	return nil, err
     }
     d.indexToValue = append(d.indexToValue, retValue)	
     index := len(d.indexToValue) - 1
     
     switch {
     
     case bytes.Equal(hashValue, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}):
     	  _, err  := d.uint8()
	  if err != nil {
     	   return nil, err
     	   }
     	  retValue.Value = nil
     case bytes.Equal(hashValue, []byte{0xc2, 0x71, 0x6e, 0x3c, 0x34, 0x13, 0xc0, 0xbe, 0xb3, 0x9e, 0x2e, 0xbc, 0xc7, 0x99, 0x62, 0x3f, 0x28, 0xe9, 0x9d, 0x19, 0x71, 0x6a, 0x0, 0x5b, 0x69, 0x4b, 0x1c, 0xbb, 0x3d, 0x8d, 0xcc, 0x45, 0xbd, 0x51, 0xca, 0x50, 0xc7, 0x3f, 0x8a, 0x64, 0xc8, 0xa0, 0xf0, 0xb, 0x46, 0x9a, 0x87, 0x5, 0xe9, 0x3c, 0xb9, 0x27, 0x91, 0xdf, 0x95, 0x88, 0x1b, 0x2e, 0xfa, 0x9f, 0xc0, 0x1f, 0xcb, 0xad}):
     	  p, err := d.int8()
	  if err != nil {
     	   return nil, err
     	}
     	retValue.Value = *(p)
     case bytes.Equal(hashValue, []byte{0x9, 0x66, 0x78, 0xbb, 0x4a, 0x86, 0x63, 0x8d, 0x8e, 0xc6, 0x58, 0x8e, 0xcc, 0x2d, 0x89, 0x5a, 0x5c, 0x17, 0xb4, 0x86, 0x37, 0x8c, 0x81, 0xc2, 0xf2, 0xac, 0xf2, 0x48, 0x67, 0x57, 0x82, 0x13, 0x3e, 0x2e, 0x7d, 0x80, 0xb6, 0x66, 0x8d, 0x84, 0xc4, 0x55, 0xf4, 0xc9, 0xe1, 0x33, 0xfc, 0x71, 0xb, 0x77, 0x43, 0x63, 0x6, 0x82, 0x76, 0x63, 0x7, 0xbc, 0xf1, 0x64, 0xdb, 0xd9, 0x5c, 0x93}):
     	  p, err := d.uint8()
	  if err != nil {
     	   return nil, err
     	}
     	retValue.Value = *(p)
     case bytes.Equal(hashValue, []byte{0x99, 0x7f, 0x69, 0x9c, 0x17, 0xfd, 0x6, 0x74, 0x8c, 0x2d, 0xba, 0xc4, 0x61, 0x1, 0x35, 0x21, 0xf1, 0x97, 0xd8, 0x1e, 0x74, 0x3c, 0x2f, 0x96, 0x56, 0xe6, 0xdc, 0xfc, 0x14, 0x1e, 0xd, 0x83, 0x36, 0xdc, 0x73, 0x36, 0xb0, 0xf4, 0x9e, 0x40, 0x2b, 0xfe, 0x97, 0x6f, 0xfa, 0xa5, 0x27, 0xac, 0xe1, 0xa2, 0x57, 0x2a, 0xae, 0x6d, 0x18, 0x22, 0xe2, 0xdc, 0xd8, 0x79, 0xe0, 0xb6, 0xf6, 0x7e}):
     	  p, err := d.int16()
	  if err != nil {
     	   return nil, err
     	}
     	retValue.Value = *(p)
     case bytes.Equal(hashValue, []byte{0xa9, 0x1f, 0x92, 0xf4, 0xe9, 0x96, 0xb6, 0xd4, 0xa4, 0xcb, 0x85, 0x8d, 0x11, 0x80, 0x20, 0x10, 0xd6, 0x29, 0xba, 0x29, 0xe1, 0x89, 0x50, 0x2c, 0xa0, 0xf2, 0xcb, 0x1d, 0x86, 0xb8, 0x27, 0x3b, 0x67, 0xf3, 0x35, 0x72, 0xd1, 0x78, 0x15, 0xcc, 0xb0, 0x94, 0x94, 0x6f, 0x2, 0xab, 0x2e, 0x46, 0xcd, 0x74, 0xea, 0xf5, 0x15, 0xa, 0x26, 0xdc, 0x4e, 0xf7, 0xd, 0x9f, 0x3a, 0x9c, 0x6e, 0x55}):
     	  p, err := d.uint16()
	  if err != nil {
     	   return nil, err
     	}
     	retValue.Value = *(p)
     case bytes.Equal(hashValue, []byte{0xeb, 0xc1, 0x67, 0x8b, 0x6, 0x82, 0x70, 0x21, 0x38, 0xc2, 0xd9, 0x9e, 0x33, 0x22, 0xd1, 0xa8, 0xc7, 0x2e, 0x9b, 0x68, 0xe9, 0x41, 0x12, 0x0, 0x1e, 0x3e, 0x51, 0xa8, 0xf5, 0xd9, 0xfa, 0x34, 0xc, 0x44, 0x9c, 0x6, 0x6d, 0x9d, 0x4c, 0xe7, 0x2a, 0x6, 0xab, 0x75, 0x77, 0x5d, 0xdf, 0x28, 0x34, 0x88, 0x7c, 0x7e, 0x96, 0x97, 0xbb, 0x8a, 0x95, 0xfe, 0x7, 0x65, 0xf7, 0x7c, 0x7e, 0x4c}):
     	  p, err := d.int32()
	  if err != nil {
     	   return nil, err
     	}
     	retValue.Value = *(p)
     case bytes.Equal(hashValue, []byte{0xce, 0xf4, 0x3a, 0x5, 0xae, 0x67, 0xd9, 0x73, 0xc2, 0xa2, 0x1d, 0xf8, 0xcd, 0xf9, 0xd2, 0xde, 0x69, 0x8d, 0xd, 0xb7, 0x61, 0xb9, 0x51, 0x22, 0x58, 0xed, 0x8f, 0xb1, 0x83, 0xf1, 0x5c, 0xff, 0x5b, 0x84, 0xe2, 0x14, 0xe, 0x10, 0x68, 0x3f, 0x7a, 0xd9, 0xa7, 0x8f, 0x5b, 0xe4, 0x9e, 0x4e, 0x0, 0x7d, 0xcb, 0xfb, 0xd1, 0x69, 0x59, 0x9d, 0xbf, 0x9b, 0x75, 0x65, 0x15, 0x9e, 0x8b, 0x82}):
     	  p, err := d.uint32()
	  if err != nil {
     	   return nil, err
     	}
     	retValue.Value = *(p)
     case bytes.Equal(hashValue, []byte{0x56, 0x16, 0x70, 0x35, 0xd0, 0x9, 0x18, 0x69, 0xe, 0xae, 0xad, 0x60, 0xd1, 0xee, 0x39, 0xa8, 0x61, 0x45, 0x58, 0x5b, 0x99, 0x20, 0x94, 0x57, 0x1f, 0xb0, 0x48, 0xeb, 0xb2, 0xcf, 0x5c, 0xa5, 0x8d, 0xc7, 0x8e, 0x7e, 0x3c, 0x89, 0xcd, 0x2f, 0xdc, 0xf2, 0x1c, 0x2a, 0xe3, 0xd2, 0x7f, 0x98, 0xc2, 0xad, 0x1c, 0x3d, 0x4e, 0x62, 0xd9, 0xdb, 0xc8, 0xc8, 0x59, 0xc5, 0xd5, 0xc6, 0xed, 0x7a}):
     	  p, err := d.int64()
	  if err != nil {
     	   return nil, err
     	}
     	retValue.Value = *(p)
     case bytes.Equal(hashValue, []byte{0x11, 0x26, 0xb3, 0xd, 0x51, 0x59, 0x87, 0x5e, 0xd, 0x5b, 0x93, 0xfc, 0x92, 0xf0, 0x78, 0xaa, 0x12, 0xac, 0x93, 0xb8, 0x30, 0x1f, 0x48, 0xe, 0x13, 0x4d, 0x8b, 0xfb, 0x4c, 0x58, 0xfa, 0x3a, 0x69, 0x6a, 0x81, 0x1, 0xc5, 0x47, 0xc1, 0x55, 0x43, 0x95, 0x41, 0xdf, 0x3c, 0x8e, 0xb6, 0x96, 0x4a, 0x3c, 0x88, 0xab, 0x3f, 0x88, 0xed, 0x37, 0x5f, 0x8, 0x4a, 0x41, 0x8e, 0xd5, 0xda, 0x1e}):
     	  p, err := d.uint64()
	  if err != nil {
     	   return nil, err
     	}
     	retValue.Value = *(p)
     case bytes.Equal(hashValue, []byte{0x42, 0x36, 0xae, 0xd3, 0x62, 0xca, 0x34, 0x75, 0x94, 0x52, 0xf0, 0x5f, 0x44, 0x83, 0x61, 0x75, 0x69, 0x39, 0xcf, 0x69, 0x74, 0x91, 0xee, 0x8d, 0x35, 0x8c, 0xd7, 0xa1, 0x63, 0xf, 0x88, 0x86, 0x6b, 0x52, 0xdd, 0x6d, 0xe1, 0xb2, 0x26, 0xf4, 0x3a, 0x9c, 0x9e, 0xf1, 0x56, 0xd, 0xf1, 0x48, 0x7, 0x39, 0x46, 0xf8, 0xe9, 0xd3, 0xab, 0x86, 0xe0, 0x1c, 0x98, 0xd, 0x17, 0x6b, 0x2, 0x63}):
     	  p, err := d.float32()
	  if err != nil {
     	   return nil, err
     	}
     	retValue.Value = *(p)
     case bytes.Equal(hashValue, []byte{0x65, 0x9b, 0xb2, 0x59, 0x85, 0xe2, 0x60, 0xe7, 0x1e, 0x12, 0x17, 0x3f, 0xc3, 0x1f, 0x20, 0x45, 0x8, 0x9e, 0x7e, 0x11, 0x6b, 0xaa, 0xb3, 0x1e, 0x6d, 0x7d, 0x7a, 0x5b, 0xe3, 0x3d, 0x40, 0xb5, 0x40, 0x6, 0x52, 0x85, 0x37, 0x80, 0x2c, 0xd8, 0x7d, 0x48, 0x67, 0xe3, 0x9a, 0xdd, 0xc9, 0x13, 0x11, 0x2c, 0xa5, 0xcc, 0x5a, 0x33, 0xbc, 0x35, 0x6b, 0x3e, 0xa8, 0x75, 0x93, 0x84, 0xcf, 0x1b}):
     	  p, err := d.float64()
	  if err != nil {
     	   return nil, err
     	}
     	retValue.Value = *(p)
     case bytes.Equal(hashValue, []byte{0x3e, 0x76, 0x6, 0x81, 0x73, 0x27, 0x61, 0xed, 0x16, 0x8e, 0xa3, 0x8, 0xe1, 0x10, 0x11, 0x85, 0xe1, 0xbd, 0x39, 0x2, 0xee, 0x67, 0x60, 0x21, 0x6a, 0x59, 0xc4, 0x7, 0x5a, 0x99, 0xc1, 0x46, 0xb7, 0xcd, 0x98, 0x14, 0xce, 0x14, 0x47, 0xe, 0xb0, 0x80, 0x6d, 0x91, 0x66, 0x50, 0xb0, 0xe5, 0xe, 0x77, 0x6f, 0x53, 0xe5, 0xd1, 0x72, 0x28, 0x1d, 0xd0, 0xe1, 0x70, 0x43, 0xc8, 0x65, 0x39}):
     	  p, err := d.bool()
	  if err != nil {
     	   return nil, err
     	}
     	retValue.Value = *(p)
     case bytes.Equal(hashValue, []byte{0x27, 0x57, 0xcb, 0x3c, 0xaf, 0xc3, 0x9a, 0xf4, 0x51, 0xab, 0xb2, 0x69, 0x7b, 0xe7, 0x9b, 0x4a, 0xb6, 0x1d, 0x63, 0xd7, 0x4d, 0x85, 0xb0, 0x41, 0x86, 0x29, 0xde, 0x8c, 0x26, 0x81, 0x1b, 0x52, 0x9f, 0x3f, 0x37, 0x80, 0xd0, 0x15, 0x0, 0x63, 0xff, 0x55, 0xa2, 0xbe, 0xee, 0x74, 0xc4, 0xec, 0x10, 0x2a, 0x2a, 0x27, 0x31, 0xa1, 0xf1, 0xf7, 0xf1, 0xd, 0x47, 0x3a, 0xd1, 0x8a, 0x6a, 0x87}):
     	  p, err := d.string()
	  if err != nil {
     	     return nil, err
     	  }
     	retValue.Value = *(p)
     default:
	e := fmt.Errorf("Wrong type used as Any")
	return retValue, e
     }
     d.indexToValue[index] = retValue		
     return retValue, nil
}

func (d *Decoder) AnyInternal() (retValue *Any, error os.Error) {
     // hashValue := d.string()
     l, err := d.uint32()
     if err != nil {
     	return nil, err
     }
     hashValue := make([]byte, *l)
     err = d.SliceOfBytes(hashValue, *l)
     if err != nil {
     	return nil, err
     }

     

     switch {
     
     case bytes.Equal(hashValue, []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}):
     _, err := d.uint8()
     if err != nil {
     	return nil, err
     }
     retValue.Value = nil
     case bytes.Equal(hashValue, []byte{0xc2, 0x71, 0x6e, 0x3c, 0x34, 0x13, 0xc0, 0xbe, 0xb3, 0x9e, 0x2e, 0xbc, 0xc7, 0x99, 0x62, 0x3f, 0x28, 0xe9, 0x9d, 0x19, 0x71, 0x6a, 0x0, 0x5b, 0x69, 0x4b, 0x1c, 0xbb, 0x3d, 0x8d, 0xcc, 0x45, 0xbd, 0x51, 0xca, 0x50, 0xc7, 0x3f, 0x8a, 0x64, 0xc8, 0xa0, 0xf0, 0xb, 0x46, 0x9a, 0x87, 0x5, 0xe9, 0x3c, 0xb9, 0x27, 0x91, 0xdf, 0x95, 0x88, 0x1b, 0x2e, 0xfa, 0x9f, 0xc0, 0x1f, 0xcb, 0xad}):
     	  p, err := d.int8()
	  if err != nil {
     	     return nil, err
	  }
     	retValue.Value = *(p)
     case bytes.Equal(hashValue, []byte{0x9, 0x66, 0x78, 0xbb, 0x4a, 0x86, 0x63, 0x8d, 0x8e, 0xc6, 0x58, 0x8e, 0xcc, 0x2d, 0x89, 0x5a, 0x5c, 0x17, 0xb4, 0x86, 0x37, 0x8c, 0x81, 0xc2, 0xf2, 0xac, 0xf2, 0x48, 0x67, 0x57, 0x82, 0x13, 0x3e, 0x2e, 0x7d, 0x80, 0xb6, 0x66, 0x8d, 0x84, 0xc4, 0x55, 0xf4, 0xc9, 0xe1, 0x33, 0xfc, 0x71, 0xb, 0x77, 0x43, 0x63, 0x6, 0x82, 0x76, 0x63, 0x7, 0xbc, 0xf1, 0x64, 0xdb, 0xd9, 0x5c, 0x93}):
     	  p, err := d.uint8()
	  if err != nil {
     	     return nil, err
	  }
     	retValue.Value = *(p)
     case bytes.Equal(hashValue, []byte{0x99, 0x7f, 0x69, 0x9c, 0x17, 0xfd, 0x6, 0x74, 0x8c, 0x2d, 0xba, 0xc4, 0x61, 0x1, 0x35, 0x21, 0xf1, 0x97, 0xd8, 0x1e, 0x74, 0x3c, 0x2f, 0x96, 0x56, 0xe6, 0xdc, 0xfc, 0x14, 0x1e, 0xd, 0x83, 0x36, 0xdc, 0x73, 0x36, 0xb0, 0xf4, 0x9e, 0x40, 0x2b, 0xfe, 0x97, 0x6f, 0xfa, 0xa5, 0x27, 0xac, 0xe1, 0xa2, 0x57, 0x2a, 0xae, 0x6d, 0x18, 0x22, 0xe2, 0xdc, 0xd8, 0x79, 0xe0, 0xb6, 0xf6, 0x7e}):
     	  p, err := d.int16()
	  if err != nil {
     	     return nil, err
	  }
     	retValue.Value = *(p)
     case bytes.Equal(hashValue, []byte{0xa9, 0x1f, 0x92, 0xf4, 0xe9, 0x96, 0xb6, 0xd4, 0xa4, 0xcb, 0x85, 0x8d, 0x11, 0x80, 0x20, 0x10, 0xd6, 0x29, 0xba, 0x29, 0xe1, 0x89, 0x50, 0x2c, 0xa0, 0xf2, 0xcb, 0x1d, 0x86, 0xb8, 0x27, 0x3b, 0x67, 0xf3, 0x35, 0x72, 0xd1, 0x78, 0x15, 0xcc, 0xb0, 0x94, 0x94, 0x6f, 0x2, 0xab, 0x2e, 0x46, 0xcd, 0x74, 0xea, 0xf5, 0x15, 0xa, 0x26, 0xdc, 0x4e, 0xf7, 0xd, 0x9f, 0x3a, 0x9c, 0x6e, 0x55}):
     	  p, err := d.uint16()
	  if err != nil {
     	     return nil, err
	  }
     	retValue.Value = *(p)
     case bytes.Equal(hashValue, []byte{0xeb, 0xc1, 0x67, 0x8b, 0x6, 0x82, 0x70, 0x21, 0x38, 0xc2, 0xd9, 0x9e, 0x33, 0x22, 0xd1, 0xa8, 0xc7, 0x2e, 0x9b, 0x68, 0xe9, 0x41, 0x12, 0x0, 0x1e, 0x3e, 0x51, 0xa8, 0xf5, 0xd9, 0xfa, 0x34, 0xc, 0x44, 0x9c, 0x6, 0x6d, 0x9d, 0x4c, 0xe7, 0x2a, 0x6, 0xab, 0x75, 0x77, 0x5d, 0xdf, 0x28, 0x34, 0x88, 0x7c, 0x7e, 0x96, 0x97, 0xbb, 0x8a, 0x95, 0xfe, 0x7, 0x65, 0xf7, 0x7c, 0x7e, 0x4c}):
     	  p, err := d.int32()
	  if err != nil {
     	     return nil, err
	  }
     	retValue.Value = *(p)
     case bytes.Equal(hashValue, []byte{0xce, 0xf4, 0x3a, 0x5, 0xae, 0x67, 0xd9, 0x73, 0xc2, 0xa2, 0x1d, 0xf8, 0xcd, 0xf9, 0xd2, 0xde, 0x69, 0x8d, 0xd, 0xb7, 0x61, 0xb9, 0x51, 0x22, 0x58, 0xed, 0x8f, 0xb1, 0x83, 0xf1, 0x5c, 0xff, 0x5b, 0x84, 0xe2, 0x14, 0xe, 0x10, 0x68, 0x3f, 0x7a, 0xd9, 0xa7, 0x8f, 0x5b, 0xe4, 0x9e, 0x4e, 0x0, 0x7d, 0xcb, 0xfb, 0xd1, 0x69, 0x59, 0x9d, 0xbf, 0x9b, 0x75, 0x65, 0x15, 0x9e, 0x8b, 0x82}):
     	  p, err := d.uint32()
	  if err != nil {
     	     return nil, err
	  }
     	retValue.Value = *(p)
     case bytes.Equal(hashValue, []byte{0x56, 0x16, 0x70, 0x35, 0xd0, 0x9, 0x18, 0x69, 0xe, 0xae, 0xad, 0x60, 0xd1, 0xee, 0x39, 0xa8, 0x61, 0x45, 0x58, 0x5b, 0x99, 0x20, 0x94, 0x57, 0x1f, 0xb0, 0x48, 0xeb, 0xb2, 0xcf, 0x5c, 0xa5, 0x8d, 0xc7, 0x8e, 0x7e, 0x3c, 0x89, 0xcd, 0x2f, 0xdc, 0xf2, 0x1c, 0x2a, 0xe3, 0xd2, 0x7f, 0x98, 0xc2, 0xad, 0x1c, 0x3d, 0x4e, 0x62, 0xd9, 0xdb, 0xc8, 0xc8, 0x59, 0xc5, 0xd5, 0xc6, 0xed, 0x7a}):
     	  p, err := d.int64()
	  if err != nil {
     	     return nil, err
	  }
     	retValue.Value = *(p)
     case bytes.Equal(hashValue, []byte{0x11, 0x26, 0xb3, 0xd, 0x51, 0x59, 0x87, 0x5e, 0xd, 0x5b, 0x93, 0xfc, 0x92, 0xf0, 0x78, 0xaa, 0x12, 0xac, 0x93, 0xb8, 0x30, 0x1f, 0x48, 0xe, 0x13, 0x4d, 0x8b, 0xfb, 0x4c, 0x58, 0xfa, 0x3a, 0x69, 0x6a, 0x81, 0x1, 0xc5, 0x47, 0xc1, 0x55, 0x43, 0x95, 0x41, 0xdf, 0x3c, 0x8e, 0xb6, 0x96, 0x4a, 0x3c, 0x88, 0xab, 0x3f, 0x88, 0xed, 0x37, 0x5f, 0x8, 0x4a, 0x41, 0x8e, 0xd5, 0xda, 0x1e}):
     	  p, err := d.uint64()
	  if err != nil {
     	     return nil, err
	  }
     	retValue.Value = *(p)
     case bytes.Equal(hashValue, []byte{0x42, 0x36, 0xae, 0xd3, 0x62, 0xca, 0x34, 0x75, 0x94, 0x52, 0xf0, 0x5f, 0x44, 0x83, 0x61, 0x75, 0x69, 0x39, 0xcf, 0x69, 0x74, 0x91, 0xee, 0x8d, 0x35, 0x8c, 0xd7, 0xa1, 0x63, 0xf, 0x88, 0x86, 0x6b, 0x52, 0xdd, 0x6d, 0xe1, 0xb2, 0x26, 0xf4, 0x3a, 0x9c, 0x9e, 0xf1, 0x56, 0xd, 0xf1, 0x48, 0x7, 0x39, 0x46, 0xf8, 0xe9, 0xd3, 0xab, 0x86, 0xe0, 0x1c, 0x98, 0xd, 0x17, 0x6b, 0x2, 0x63}):
     	  p, err := d.float32()
	  if err != nil {
     	     return nil, err
	  }
     	retValue.Value = *(p)
     case bytes.Equal(hashValue, []byte{0x65, 0x9b, 0xb2, 0x59, 0x85, 0xe2, 0x60, 0xe7, 0x1e, 0x12, 0x17, 0x3f, 0xc3, 0x1f, 0x20, 0x45, 0x8, 0x9e, 0x7e, 0x11, 0x6b, 0xaa, 0xb3, 0x1e, 0x6d, 0x7d, 0x7a, 0x5b, 0xe3, 0x3d, 0x40, 0xb5, 0x40, 0x6, 0x52, 0x85, 0x37, 0x80, 0x2c, 0xd8, 0x7d, 0x48, 0x67, 0xe3, 0x9a, 0xdd, 0xc9, 0x13, 0x11, 0x2c, 0xa5, 0xcc, 0x5a, 0x33, 0xbc, 0x35, 0x6b, 0x3e, 0xa8, 0x75, 0x93, 0x84, 0xcf, 0x1b}):
     	  p, err := d.float64()
	  if err != nil {
     	     return nil, err
	  }
     	retValue.Value = *(p)
     case bytes.Equal(hashValue, []byte{0x3e, 0x76, 0x6, 0x81, 0x73, 0x27, 0x61, 0xed, 0x16, 0x8e, 0xa3, 0x8, 0xe1, 0x10, 0x11, 0x85, 0xe1, 0xbd, 0x39, 0x2, 0xee, 0x67, 0x60, 0x21, 0x6a, 0x59, 0xc4, 0x7, 0x5a, 0x99, 0xc1, 0x46, 0xb7, 0xcd, 0x98, 0x14, 0xce, 0x14, 0x47, 0xe, 0xb0, 0x80, 0x6d, 0x91, 0x66, 0x50, 0xb0, 0xe5, 0xe, 0x77, 0x6f, 0x53, 0xe5, 0xd1, 0x72, 0x28, 0x1d, 0xd0, 0xe1, 0x70, 0x43, 0xc8, 0x65, 0x39}):
     	  p, err := d.bool()
	  if err != nil {
     	     return nil, err
	  }
     	retValue.Value = *(p)
     case bytes.Equal(hashValue, []byte{0x27, 0x57, 0xcb, 0x3c, 0xaf, 0xc3, 0x9a, 0xf4, 0x51, 0xab, 0xb2, 0x69, 0x7b, 0xe7, 0x9b, 0x4a, 0xb6, 0x1d, 0x63, 0xd7, 0x4d, 0x85, 0xb0, 0x41, 0x86, 0x29, 0xde, 0x8c, 0x26, 0x81, 0x1b, 0x52, 0x9f, 0x3f, 0x37, 0x80, 0xd0, 0x15, 0x0, 0x63, 0xff, 0x55, 0xa2, 0xbe, 0xee, 0x74, 0xc4, 0xec, 0x10, 0x2a, 0x2a, 0x27, 0x31, 0xa1, 0xf1, 0xf7, 0xf1, 0xd, 0x47, 0x3a, 0xd1, 0x8a, 0x6a, 0x87}):
     	  p, err := d.string()
	  if err != nil {
     	     return nil, err
	  }
     	retValue.Value = *(p)
     default:
	e := fmt.Errorf("Wrong type used as Any")
	return retValue, e
     }
     return retValue, nil
}


type Any struct{Value interface{}}

const(
	pNIL = 0
	pIDX = 1
	pVAL = 2
	BufSize = 1024 * 50
)




type Encoder struct {
	w io.Writer
	buf []byte
	t *TypeTree
	m []interface{} // this is for storing maps
	curPos int
	bufSpace uint32
	bufStart uint32
	bufLen uint32
	count uint32
}
type Decoder struct {
	r io.Reader
	buf []byte
	indexToValue []interface{}
	m []interface{} // this is for storing maps
	curPos uint32
	bufStart uint32
	bufLen uint32
}

func NewEncoder(w io.Writer) *Encoder {
	return &Encoder{w:w, buf:make([]byte, BufSize), t: NewTypeTree(), curPos:4, bufSpace:BufSize, bufStart:0, bufLen:0, count:0}
}

func NewDecoder(r io.Reader) *Decoder {
	return &Decoder{r:r, buf:make([]byte, BufSize), curPos:0, bufStart:0, bufLen:0}
}

func (e *Encoder) MapCheck(t interface{}) (int, bool) {
	for index, entry := range e.m {
		if entry == t {
			return index, true
		}
	}
	return -1, false
}

func (e *Encoder) isEnoughSpace(length uint32) bool {
     if length <= e.bufSpace {
     	return true
     }    
     return false
}

func (d *Decoder) isEnoughData(length uint32) bool {
     if length <= d.bufLen {
     	return true
     }
     return false
}


func (d *Decoder) readAtLeast(length uint32) os.Error{
     if d.bufLen > 0 {
     	copy(d.buf, d.buf[d.bufStart:(d.bufStart + d.bufLen)])
     }
     n, err := io.ReadAtLeast(d.r, d.buf[d.bufLen:], int(length))
     if err != nil {
	return err
     }
     d.bufLen += uint32(n)
     d.bufStart = 0
     return nil
}

func (e *Encoder) byte(b byte) (os.Error){
     return e.uint8(uint8(b))
     
}

func (e *Encoder) Byte(b Byte) (os.Error) {
	return e.byte(byte(b))
}

func (d *Decoder) byte() (b *byte, error os.Error) {
     v, err := d.uint8()
     if err != nil {
        return nil, err
     }
     value := byte(*v)
     return &value, err
}

func (d *Decoder) Byte() (*Byte, os.Error) {
     b, err := d.byte()
     if err != nil {
          return nil, err
     }
     B := Byte(*b)
     return &B, nil
}

func (e *Encoder) uint8(u uint8) os.Error{
     	// e.write([]byte{byte(u)})
	// e.buf[e.curPos] = byte(u)
	// e.curPos++
	if !e.isEnoughSpace(1) {
	   err := e.Flush() 
	   if err != nil {
	      return err
	   }
	}
	e.buf[e.bufStart] = byte(u)
	e.bufStart = (e.bufStart + 1) % BufSize
	e.bufLen++
	e.bufSpace--
	return nil
}

func (e *Encoder) Uint8(u Uint8) (os.Error){
     return e.uint8(uint8(u))
}

func (e *Encoder) int8(u int8) (os.Error){
     return e.int8(u)
}

func (e *Encoder) Int8(u Int8) (os.Error){
     return e.uint8(uint8(u))
}

func (e *Encoder) Int8Boxed(u Int8) (os.Error){
     return e.int8(int8(u))
}

func (d *Decoder) uint8() (w *uint8, err os.Error) {
	if !d.isEnoughData(1) {
	   err = d.readAtLeast(1)	   
	   if err != nil {
	      return nil, err
	   }
	}
	v := uint8(d.buf[d.bufStart])
	d.bufStart = (d.bufStart + 1) % BufSize
	d.bufLen -= 1
	return &v, nil
}

func (d *Decoder) Uint8() (*Uint8, os.Error) {
     w, err := d.uint8()
     if err != nil {
          return nil, err
     }
     W := Uint8(*w)
     return &W, nil
}

func (d *Decoder) int8() (w *int8, error os.Error) {
     	v, err := d.uint8()
	if err != nil {
		return nil, err
	}
	r := int8(*v)
	return &r, err
}

func (d *Decoder) Int8() (*Int8, os.Error) {
     i, err := d.int8()
     if err != nil {
         return nil, err
     }
     I := Int8(*i)
     return &I, nil
}

func (e *Encoder) uint16(u uint16) os.Error{
	if !e.isEnoughSpace(2) {
	   err := e.Flush() 
	   if err != nil {
	      return err
	   }
	}
	e.buf[e.bufStart] = byte(u)
	e.bufStart = (e.bufStart + 1) % BufSize
	e.buf[e.bufStart] = byte(u >> 8)
   	e.bufStart = (e.bufStart + 1) % BufSize
	e.bufLen += 2
	e.bufSpace -= 2
	return nil
}

func (e *Encoder) Uint16(u Uint16) (os.Error){
     return e.uint16(uint16(u))
}

func (e *Encoder) int16(u int16) (os.Error){
	return e.uint16(uint16(u))
}

func (e *Encoder) Int16(u Int16) (os.Error){
     return e.int16(int16(u))
}

func (d *Decoder) uint16() (w *uint16, err os.Error) {
	if !d.isEnoughData(2) {
	   err = d.readAtLeast(2)	   
	   if err != nil {
	      return nil, err
	   }
	}
	v := uint16(d.buf[d.bufStart]) | uint16(d.buf[d.bufStart + 1]) << 8
	d.bufStart = (d.bufStart + 2) % BufSize
	d.bufLen -= 2
	return &v, nil
}

func (d *Decoder) Uint16() (*Uint16, os.Error) {
     u, err := d.uint16()
     if err != nil {
          return nil, err
     }
     U := Uint16(*u)
     return &U, err
}

func (d *Decoder) int16() (w *int16, error os.Error) {
     	v, err := d.uint16()
	if err != nil {
		return nil, err
	}
	r := int16(*v)
	return &r, err
}

func (d *Decoder) Int16() (w *Int16, err os.Error) {
	u, err := d.uint16()
	if err != nil {
		return nil, err
	}
	U := Int16(*u)
	return &U, err
}

func (e *Encoder) uint32(u uint32) os.Error{
	if !e.isEnoughSpace(4) {
	   err := e.Flush()   		      
	   if err != nil {
	      return err
	   }
	}
	e.buf[e.bufStart] = byte(u)
	e.bufStart = (e.bufStart + 1) % BufSize
	e.buf[e.bufStart] = byte(u >> 8)
   	e.bufStart = (e.bufStart + 1) % BufSize
	e.buf[e.bufStart] = byte(u >> 16)
   	e.bufStart = (e.bufStart + 1) % BufSize
	e.buf[e.bufStart] = byte(u >> 24)
   	e.bufStart = (e.bufStart + 1) % BufSize
	e.bufLen += 4
	e.bufSpace -= 4
	return nil
}

func (e *Encoder) Uint32(u Uint32) (os.Error){
     return e.uint32(uint32(u))
}
func (e *Encoder) int32(u int32) (os.Error){
	return e.uint32(uint32(u))
}

func (e *Encoder) Int32(u Int32) (os.Error){
     return e.int32(int32(u))
}

func (d *Decoder) uint32() (w *uint32, err os.Error) {
	if !d.isEnoughData(4) {
	   err = d.readAtLeast(4)	   
	   if err != nil {
	      return nil, err
	   }
	}
	v := uint32(d.buf[d.bufStart]) | uint32(d.buf[d.bufStart + 1]) << 8 | uint32(d.buf[d.bufStart + 2]) << 16 | uint32(d.buf[d.bufStart + 3]) << 24
	d.bufStart = (d.bufStart + 4) % BufSize
	d.bufLen -= 4
	return &v, nil
}

func (d *Decoder) Uint32() (*Uint32, os.Error) {
	w, err := d.uint32()
	if err != nil {
		return nil, err
	}
	W := Uint32(*w)
	return &W, nil
}

func (d *Decoder) int32() (w *int32, error os.Error) {
     	v, err := d.uint32()
	r := int32(*v)
	return &r, err
}

func (d *Decoder) Int32() (*Int32, os.Error) {
	w, err := d.int32()
	if err != nil {
		return nil, err
	}
	W := Int32(*w)
	return &W, nil
}

func (e *Encoder) Status(s syscall.Status) (os.Error){
	return e.uint32(uint32(s))
}


func (d *Decoder) Status() (*syscall.Status, os.Error) {
	i, err := d.uint32()
	if err != nil {
		return nil, err
	}
	S := syscall.Status(*i)
	return &S, err
}

func (e *Encoder) uint64(u uint64) os.Error{
	if !e.isEnoughSpace(8) {
	   	err := e.Flush()    
		if err != nil {
	      	   return err
	      	}  
	}
	e.buf[e.bufStart] = byte(u)
	e.bufStart = (e.bufStart + 1) % BufSize
	e.buf[e.bufStart] = byte(u >> 8)
   	e.bufStart = (e.bufStart + 1) % BufSize
	e.buf[e.bufStart] = byte(u >> 16)
   	e.bufStart = (e.bufStart + 1) % BufSize
	e.buf[e.bufStart] = byte(u >> 24)
   	e.bufStart = (e.bufStart + 1) % BufSize
	e.buf[e.bufStart] = byte(u >> 32)
   	e.bufStart = (e.bufStart + 1) % BufSize
	e.buf[e.bufStart] = byte(u >> 40)
   	e.bufStart = (e.bufStart + 1) % BufSize
	e.buf[e.bufStart] = byte(u >> 48)
   	e.bufStart = (e.bufStart + 1) % BufSize
	e.buf[e.bufStart] = byte(u >> 56)
   	e.bufStart = (e.bufStart + 1) % BufSize
	e.bufLen += 8
	e.bufSpace -= 8
	return nil
}

func (e *Encoder) Uint64(u Uint64) (os.Error){
     return e.uint64(uint64(u))
}

func (e *Encoder) int64(u int64) (os.Error){
	return e.uint64(uint64(u))
}

func (e *Encoder) Int64(u Int64) (os.Error){
     return e.int64(int64(u))
}

func (d *Decoder) uint64() (w *uint64, err os.Error) {
	if !d.isEnoughData(8) {
	   err = d.readAtLeast(8)	   
	   if err != nil {
	      return nil, err
	   }
	}
	v := uint64(d.buf[d.bufStart]) | uint64(d.buf[d.bufStart + 1]) << 8 | uint64(d.buf[d.bufStart + 2]) << 16 | uint64(d.buf[d.bufStart + 3]) << 24 | uint64(d.buf[d.bufStart + 4]) << 32 | uint64(d.buf[d.bufStart + 5]) << 40 | uint64(d.buf[d.bufStart + 6]) << 48 | uint64(d.buf[d.bufStart + 7]) << 56
	d.bufStart = (d.bufStart + 8) % BufSize
	d.bufLen -= 8
	return &v, nil
}

func (d *Decoder) Uint64() (*Uint64, os.Error) {
	u, err := d.uint64()
	if err != nil {
		return nil, err
	}
	U := Uint64(*u)
	return &U, nil
}

func (d *Decoder) int64() (w *int64, error os.Error) {
	v, err := d.uint64()
	if err != nil {
		return nil, err
	}
	r := int64(*v)
	return &r, err
}

func (d *Decoder) Int64() (w *Int64, err os.Error) {
	i, err := d.int64()
	if err != nil {
		return nil, err
	}
	I := Int64(*i)
	return &I, nil
}

func (e *Encoder) float32(u float32) (os.Error){
	return e.uint32(math.Float32bits(u))
}

func (e *Encoder) Float32(u Float32) (os.Error){
 	return e.float32(float32(u))
}

func (d *Decoder) float32() (w *float32, error os.Error) {
     	v, err := d.uint32()
	if err != nil {
		return nil, err
	}
	r := math.Float32frombits(*v)
	return &r, err
}

func (d *Decoder) Float32() (*Float32, os.Error) {
	f, err := d.float32()
	if err != nil {
		return nil, err
	}
	F := Float32(*f)
	return &F, nil
}

func (e *Encoder) float64(u float64) (os.Error){
	return e.uint64(math.Float64bits(u))
}

func (e *Encoder) Float64(u Float64) (os.Error){
	return e.float64(float64(u))
}

func (d *Decoder) float64() (w *float64, error os.Error) {
	v, err := d.uint64()
	if err != nil {
		return nil, err
	}
	r := math.Float64frombits(*v)
	return &r, err
}

func (d *Decoder) Float64() (*Float64, os.Error) {
	f, err := d.float64()
	if err != nil {
		return nil, err
	}
	F := Float64(*f)
	return &F, nil
}

func (e *Encoder) bool(u bool) (err os.Error){
	if u {
		err = e.uint8(1)
	} else {
		err = e.uint8(0)
	}
	return err
}

func (e *Encoder) Bool(u Bool) (os.Error){
	return e.bool(bool(u))
}

func (d *Decoder) bool() (w *bool, error os.Error) {
	v, err := d.uint8()
	if err != nil {
		return nil, err
	}
	var u bool
	if *v == 1 {
		u = true
	} else {
		u = false
	}
	return &u, err
}

func (d *Decoder) Bool() (w *Bool, err os.Error) {
	b, err := d.bool()
	if err != nil {
		return nil, err
	}
	B := Bool(*b)
	return &B, nil
}

func (e *Encoder) SliceOfBytes(u []byte) (err os.Error){
     err = e.length(uint32(len(u)))
     if err != nil {
     	return err
     }
     sliceStartPos := uint32(0)
     for ;!e.isEnoughSpace(uint32(len(u[sliceStartPos:]))); {
	copy(e.buf[e.bufStart:], u[sliceStartPos:(sliceStartPos + e.bufSpace)])
	sliceStartPos += e.bufSpace
	e.bufLen += e.bufSpace
	e.bufSpace = 0
	if e.bufLen != 0 {
	   err := e.Flush()
	   if err != nil {
	      return err
	   }
	}
     } 
     if len(u[sliceStartPos:]) > 0 {
       copy(e.buf[e.bufStart:], u[sliceStartPos:])
       e.bufStart += uint32(len(u[sliceStartPos:]))	
       e.bufLen += uint32(len(u[sliceStartPos:]))
       e.bufSpace -= uint32(len(u[sliceStartPos:]))
     }
     return nil
     
}

func (d *Decoder) SliceOfBytes(v []byte, length uint32) (err os.Error){
     if length > d.bufLen {
     	copy(v, d.buf[d.bufStart:(d.bufStart + d.bufLen)])
	io.ReadFull(d.r, v[d.bufLen:])
	d.bufStart = 0
	d.bufLen = 0
	return
     }
     if !d.isEnoughData(length) {
	   err = d.readAtLeast(length)
	   if err != nil {
	      return err
	   }
	}
     copy(v, d.buf[d.bufStart: (d.bufStart + length)])
     d.bufStart = (d.bufStart + length) % BufSize
     d.bufLen -= length
     return nil
}

func (e *Encoder) string(u string) (err os.Error){
	err = e.length(uint32(len(u)))
	if err != nil {
	   return err
	}
	stringStartPos := uint32(0)
	for ;!e.isEnoughSpace(uint32(len(u[stringStartPos:]))); {
	   copy(e.buf[e.bufStart:], u[stringStartPos:(stringStartPos + e.bufSpace)])
	   stringStartPos += e.bufSpace
	   e.bufLen += e.bufSpace
	   e.bufSpace = 0
	   if e.bufSpace == 0 {
	      err = e.Flush()
	      if err != nil {
	      	 return err
	      }
	   }	  
	} 
	if len(u[stringStartPos:]) > 0 {
		copy(e.buf[e.bufStart:], u[stringStartPos:])
		e.bufStart += uint32(len(u[stringStartPos:]))
		e.bufLen += uint32(len(u[stringStartPos:]))
		e.bufSpace -= uint32(len(u[stringStartPos:]))
	}
	return nil
	
}

func (e *Encoder) String(u String) (os.Error){
     return e.string(string(u))
}

func (d *Decoder) string() (w *string, err os.Error) {
	len, err := d.length()
	if err != nil {
	   return nil, err
	}

	if len > d.bufLen {
 	   b := make([]byte, len) 
	   copy(b[0:], d.buf[d.bufStart:(d.bufStart + d.bufLen)])
	   _, err = io.ReadFull(d.r, b[d.bufLen:])
	   if err != nil {
	      return nil, err
	   }
	   d.bufStart = 0
	   d.bufLen = 0	   
	   str := string(b)
	   return &str, nil
	}
	if !d.isEnoughData(uint32(len)) {
	  	   err = d.readAtLeast(uint32(len))
		   if err != nil {
	      	      return nil, err
		   }  
	}
	b := d.buf[d.bufStart:(d.bufStart + len)]
	d.bufStart = (d.bufStart + len) % BufSize
	d.bufLen -= len
	str := string(b)
	return &str, nil
}

func (d *Decoder) String() (*String, os.Error) {
	s, err := d.string()
	if err != nil {
		return nil, err
	}
	S := String(*s)
	return &S, nil
}

func (e *Encoder) length(l uint32) (os.Error){
	// e.buf[e.curPos] = byte(l)
	// e.curPos++
	// e.buf[e.curPos] = byte(l >> 8)
	// e.curPos++
	// e.buf[e.curPos] = byte(l >> 16)
	// e.curPos++
	// e.buf[e.curPos] = byte(l >> 24)
	// e.curPos++
	// return
	return e.uint32(l)
}

func (d *Decoder) length() (l uint32, error os.Error) {
     	v, err := d.uint32()
	if err != nil {
		return 0, err
	}
	return *v, err
}

func (e *Encoder) Flush() os.Error{
	// e.bufSize = uint32(e.curPos) - 4
	// e.buf[0] = byte(e.bufSize)
	// e.buf[1] = byte(e.bufSize >> 8)
	// e.buf[2] = byte(e.bufSize >> 16)
	// e.buf[3] = byte(e.bufSize >> 24)
	// e.write(e.buf[:e.curPos])
	// e.curPos = 4
	
        // e.count++
	// if e.count %40 != 0 {
	//     return 
	// }
	if e.bufLen == 0 {
	   return nil
	}
	if _, err := e.w.Write(e.buf[:e.bufLen]); err != nil {
	   return err
	}
	e.bufStart = 0
	e.bufLen = 0
	e.bufSpace = BufSize
	e.reset()
	return nil
}

func (d *Decoder) ReadAll() {
     /* FIXME: Temporarily place reset here. We also reset in RPC calls. This 
      *        should probably go in one place: each type decoder, but we need
      *        to be able to differentiate between an application-called decode
      *        and a decode of internal elements. The latter case should not 
      *        call reset. */
     d.reset() 
}

func (e *Encoder) reset() {
	//e.t = NewTypeTree()
	e.t.Reset()
	e.m = make([]interface{}, 0)
}

func (d *Decoder) reset() {
	d.indexToValue = make([]interface{}, 0)
	d.m = make([]interface{}, 0)
	d.curPos = 0
}


func Hash(v interface{}) reflect.Type{
     return reflect.ValueOf(v).Type()
}

func Sizeof(v interface{}) uint64 {
     return uint64(unsafe.Sizeof(v))
}

// type Node struct {
// 	ptr unsafe.Pointer
// 	eleType string
// 	eleSize uint64
// 	index uint32
// }

var emptyPtrNode *llrb.Item

type TypeTree struct{
	tree *llrb.Tree
	Index uint32
	reusedItem llrb.Item
	min *llrb.Item
	max *llrb.Item
}

func lessPtr(a, b llrb.Item) bool {
	return uintptr(a.Ptr) < uintptr(b.Ptr)
}

func NewTypeTree() *TypeTree{
	t := TypeTree{}
	t.tree = llrb.New(lessPtr)
	t.Index = 0
	emptyPtrNode = &llrb.Item{0, "", 0, 0}
	return &t
}

func (t *TypeTree) Reset() {
     t.tree.Reset()
}

func (t *TypeTree) closestPtr(ptr uint64, typ string, size uint64, index uint32) (*llrb.Item, *llrb.Item){
	t.reusedItem.Ptr = ptr 
	t.reusedItem.EleType = typ
	t.reusedItem.EleSize = size
	t.reusedItem.Index = index
	minItem, maxItem := t.tree.FindAdjacentNodes(t.reusedItem)
	//minItem, maxItem = t.tree.FindAdjacentNodesLog(t.reusedItem)
	return minItem, maxItem
	
}

func (t *TypeTree) addToTree(elePtr uint64, eleType string, eleSize uint64, eleIndex uint32) {
	t.reusedItem.Ptr = elePtr 
	t.reusedItem.EleType = eleType
	t.reusedItem.EleSize = eleSize
	t.reusedItem.Index = eleIndex
	t.tree.InsertNoReplace(&t.reusedItem)
}

func (t *TypeTree) PointerCheck(ptr_unsafe unsafe.Pointer, typ string, size uint64) (index uint32, encoded bool, err os.Error) {
       	
	ptr := uint64(uintptr(ptr_unsafe))
	t.reusedItem.Ptr = ptr 
	t.reusedItem.EleType = typ
	t.reusedItem.EleSize = size
	t.reusedItem.Index = 0
	sameItem := t.tree.Get(t.reusedItem)
	t.min, t.max = t.closestPtr(ptr, sameItem.EleType, sameItem.EleSize, sameItem.Index) 
	switch {
	case !sameItem.Equal(emptyPtrNode)  && sameItem.EleType == typ:
		// already in the tree
		return sameItem.Index, true, nil
	case !sameItem.Equal(emptyPtrNode)  && sameItem.EleType != typ:
		t.addToTree(ptr, typ, size, t.Index)
		t.Index++
		return t.Index, false, nil
	case (t.min.Equal(emptyPtrNode) && !t.max.Equal(emptyPtrNode) && (ptr + size) <= t.max.Ptr) ||
	     (!t.min.Equal(emptyPtrNode) && t.max.Equal(emptyPtrNode) && ptr >= (t.min.Ptr + t.min.EleSize)) ||
	     (!t.min.Equal(emptyPtrNode) && !t.max.Equal(emptyPtrNode) && (ptr + size) <= t.max.Ptr && ptr >= (t.min.Ptr + t.min.EleSize)) ||
	     (t.min.Equal(emptyPtrNode) && t.max.Equal(emptyPtrNode)):
		t.addToTree(ptr, typ, size, t.Index)
		t.Index++
		return t.Index, false, nil
	default:
		e := fmt.Errorf("Illegal pointer")
		return 0, false, e
	}
	e := fmt.Errorf("Illegal pointer")
	return 0, false, e
}


/*type BufferedIO struct{
	writeBuf []byte
	readBuf []byte
	readBufCount int
	head int
	hasReadOnce bool
	conn net.Conn
	writeBufStart int
	writeBufLen int
}
var ReadBufSize = 1024*40

func NewBufferedIO(conn net.Conn) (bufIO *BufferedIO, error os.Error){
	//buff := make([]byte, 4096*1024)
	bufIO = &BufferedIO{}
	if conn == nil{
		return nil, os.EINVAL
	}
	bufIO.conn = conn
	bufIO.readBuf = make([]byte, ReadBufSize)
	bufIO.readBufCount = 0
	bufIO.head = 0
	bufIO.hasReadOnce = false
	bufIO.writeBuf = make([]byte, ReadBufSize)
	bufIO.writeBufStart = 0
	bufIO.writeBufLen = 0
	return bufIO, error
}

func (bo *BufferedIO) GetConn() net.Conn{
	return bo.conn
}

func (bo *BufferedIO) Write(b []byte) (n int, err os.Error){
	copy(bo.writeBuf[bo.writeBufStart:], b)
	bo.writeBufLen += len(b)
	bo.writeBufStart = bo.writeBufLen
	return bo.writeBufLen, nil
}

func (bo *BufferedIO) Flush() os.Error{

	if bo.writeBuf != nil{
		_, error := bo.conn.Write(bo.writeBuf[:bo.writeBufLen])
		bo.writeBufStart = 0
		bo.writeBufLen = 0
		return error
	}

	return nil
}

func DoMove (dest []byte, src *BufferedIO, size int) {
	copy(dest, src.readBuf[src.head:src.head+size])
	src.readBufCount -= size
	src.head += size
}

func (bo *BufferedIO) Read(b []byte) (n int, err os.Error){
	// read the smaller of the size of b, or what's left in bo
	//MyPrint("Read is called")
	copied :=  len(b)
	if bo.readBufCount < len(b) {
		copied = bo.readBufCount
	}
	remainder := len (b) - copied
	DoMove (b, bo, copied)
	//MyPrint ("READ", bo.readBuf[:copied])

	if remainder > ReadBufSize { // big read, do it directly
		n, err = bo.conn.Read (b[copied:])
		if err != nil {
			return n, err
		}
		//MyPrint("REAL READ", b[copied:])
	} else if remainder != 0 { // small read, buffer it
		n, err = io.ReadAtLeast (bo.conn, bo.readBuf, remainder)
		bo.readBufCount = n
		bo.head = 0
		//MyPrint("REAL READ", bo.readBuf)
		if err != nil {
			return n, err
		}
		DoMove (b[copied:], bo, remainder)
		//MyPrint("READ", b[copied:])
		//b = append (b, bo.readBuf[:remainder])
	}
	return len(b), err
}

func (bo *BufferedIO) Close() os.Error{
	var error os.Error

	if bo.writeBuf != nil{
		//MyPrint("Flush buffer before close", bo, bo.conn, bo.writeBuf)
		_, error = bo.conn.Write(bo.writeBuf[:bo.writeBufLen])
		bo.writeBufStart = 0
		bo.writeBufLen = 0
	}else{
		//MyPrint("No data to flush before close")
	}
	//MyPrint("CLOSE", bo.buf[:len(bo.buf)])
	if error != nil{
		bo.conn.Close()
		return error
	}
	if bo.conn != nil{
		return bo.conn.Close()
	}
	return nil
	//return bo.conn.Close()
}*/
func (t *Int8) WriteBuffer() ([]byte, syscall.Status) {
	var buffer bytes.Buffer
	e := NewEncoder(&buffer)
	err := e.Int8(*t)
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	err = e.Flush()
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	return buffer.Bytes(), syscall.StatusOk
}

func (t *Int8) ReadBuffer(buffer []byte) (syscall.Status) {
	d := NewDecoder(bytes.NewBuffer(buffer))
	value, err := d.Int8()
	if err != nil {
		return syscall.StatusFail
	}

	*t = *value
	return syscall.StatusOk
}

func (t *Int8) GetHash() (syscall.HashValue) {
	return  syscall.HashValue{ 0xc2,0x71,0x6e,0x3c,0x34,0x13,0xc0,0xbe,0xb3,0x9e,0x2e,0xbc,0xc7,0x99,0x62,0x3f,0x28,0xe9,0x9d,0x19,0x71,0x6a,0x00,0x5b,0x69,0x4b,0x1c,0xbb,0x3d,0x8d,0xcc,0x45,0xbd,0x51,0xca,0x50,0xc7,0x3f,0x8a,0x64,0xc8,0xa0,0xf0,0x0b,0x46,0x9a,0x87,0x05,0xe9,0x3c,0xb9,0x27,0x91,0xdf,0x95,0x88,0x1b,0x2e,0xfa,0x9f,0xc0,0x1f,0xcb,0xad, }
}
func (t *Uint8) WriteBuffer() ([]byte, syscall.Status) {
	var buffer bytes.Buffer
	e := NewEncoder(&buffer)
	err := e.Uint8(*t)
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	err = e.Flush()
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	return buffer.Bytes(), syscall.StatusOk
}

func (t *Uint8) ReadBuffer(buffer []byte) (syscall.Status) {
	d := NewDecoder(bytes.NewBuffer(buffer))
	value, err := d.Uint8()
	if err != nil {
		return syscall.StatusFail
	}

	*t = *value
	return syscall.StatusOk
}

func (t *Uint8) GetHash() (syscall.HashValue) {
	return  syscall.HashValue{ 0x09,0x66,0x78,0xbb,0x4a,0x86,0x63,0x8d,0x8e,0xc6,0x58,0x8e,0xcc,0x2d,0x89,0x5a,0x5c,0x17,0xb4,0x86,0x37,0x8c,0x81,0xc2,0xf2,0xac,0xf2,0x48,0x67,0x57,0x82,0x13,0x3e,0x2e,0x7d,0x80,0xb6,0x66,0x8d,0x84,0xc4,0x55,0xf4,0xc9,0xe1,0x33,0xfc,0x71,0x0b,0x77,0x43,0x63,0x06,0x82,0x76,0x63,0x07,0xbc,0xf1,0x64,0xdb,0xd9,0x5c,0x93, }
}
func (t *Bool) WriteBuffer() ([]byte, syscall.Status) {
	var buffer bytes.Buffer
	e := NewEncoder(&buffer)
	err := e.Bool(*t)
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	err = e.Flush()
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	return buffer.Bytes(), syscall.StatusOk
}

func (t *Bool) ReadBuffer(buffer []byte) (syscall.Status) {
	d := NewDecoder(bytes.NewBuffer(buffer))
	value, err := d.Bool()
	if err != nil {
		return syscall.StatusFail
	}

	*t = *value
	return syscall.StatusOk
}

func (t *Bool) GetHash() (syscall.HashValue) {
	return  syscall.HashValue{ 0x3e,0x76,0x06,0x81,0x73,0x27,0x61,0xed,0x16,0x8e,0xa3,0x08,0xe1,0x10,0x11,0x85,0xe1,0xbd,0x39,0x02,0xee,0x67,0x60,0x21,0x6a,0x59,0xc4,0x07,0x5a,0x99,0xc1,0x46,0xb7,0xcd,0x98,0x14,0xce,0x14,0x47,0x0e,0xb0,0x80,0x6d,0x91,0x66,0x50,0xb0,0xe5,0x0e,0x77,0x6f,0x53,0xe5,0xd1,0x72,0x28,0x1d,0xd0,0xe1,0x70,0x43,0xc8,0x65,0x39, }
}
func (t *Int16) WriteBuffer() ([]byte, syscall.Status) {
	var buffer bytes.Buffer
	e := NewEncoder(&buffer)
	err := e.Int16(*t)
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	err = e.Flush()
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	return buffer.Bytes(), syscall.StatusOk
}

func (t *Int16) ReadBuffer(buffer []byte) (syscall.Status) {
	d := NewDecoder(bytes.NewBuffer(buffer))
	value, err := d.Int16()
	if err != nil {
		return syscall.StatusFail
	}

	*t = *value
	return syscall.StatusOk
}

func (t *Int16) GetHash() (syscall.HashValue) {
	return  syscall.HashValue{ 0x99,0x7f,0x69,0x9c,0x17,0xfd,0x06,0x74,0x8c,0x2d,0xba,0xc4,0x61,0x01,0x35,0x21,0xf1,0x97,0xd8,0x1e,0x74,0x3c,0x2f,0x96,0x56,0xe6,0xdc,0xfc,0x14,0x1e,0x0d,0x83,0x36,0xdc,0x73,0x36,0xb0,0xf4,0x9e,0x40,0x2b,0xfe,0x97,0x6f,0xfa,0xa5,0x27,0xac,0xe1,0xa2,0x57,0x2a,0xae,0x6d,0x18,0x22,0xe2,0xdc,0xd8,0x79,0xe0,0xb6,0xf6,0x7e, }
}
func (t *Uint16) WriteBuffer() ([]byte, syscall.Status) {
	var buffer bytes.Buffer
	e := NewEncoder(&buffer)
	err := e.Uint16(*t)
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	err = e.Flush()
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	return buffer.Bytes(), syscall.StatusOk
}

func (t *Uint16) ReadBuffer(buffer []byte) (syscall.Status) {
	d := NewDecoder(bytes.NewBuffer(buffer))
	value, err := d.Uint16()
	if err != nil {
		return syscall.StatusFail
	}

	*t = *value
	return syscall.StatusOk
}

func (t *Uint16) GetHash() (syscall.HashValue) {
	return  syscall.HashValue{ 0xa9,0x1f,0x92,0xf4,0xe9,0x96,0xb6,0xd4,0xa4,0xcb,0x85,0x8d,0x11,0x80,0x20,0x10,0xd6,0x29,0xba,0x29,0xe1,0x89,0x50,0x2c,0xa0,0xf2,0xcb,0x1d,0x86,0xb8,0x27,0x3b,0x67,0xf3,0x35,0x72,0xd1,0x78,0x15,0xcc,0xb0,0x94,0x94,0x6f,0x02,0xab,0x2e,0x46,0xcd,0x74,0xea,0xf5,0x15,0x0a,0x26,0xdc,0x4e,0xf7,0x0d,0x9f,0x3a,0x9c,0x6e,0x55, }
}
func (t *Int32) WriteBuffer() ([]byte, syscall.Status) {
	var buffer bytes.Buffer
	e := NewEncoder(&buffer)
	err := e.Int32(*t)
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	err = e.Flush()
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	return buffer.Bytes(), syscall.StatusOk
}

func (t *Int32) ReadBuffer(buffer []byte) (syscall.Status) {
	d := NewDecoder(bytes.NewBuffer(buffer))
	value, err := d.Int32()
	if err != nil {
		return syscall.StatusFail
	}

	*t = *value
	return syscall.StatusOk
}

func (t *Int32) GetHash() (syscall.HashValue) {
	return  syscall.HashValue{ 0xeb,0xc1,0x67,0x8b,0x06,0x82,0x70,0x21,0x38,0xc2,0xd9,0x9e,0x33,0x22,0xd1,0xa8,0xc7,0x2e,0x9b,0x68,0xe9,0x41,0x12,0x00,0x1e,0x3e,0x51,0xa8,0xf5,0xd9,0xfa,0x34,0x0c,0x44,0x9c,0x06,0x6d,0x9d,0x4c,0xe7,0x2a,0x06,0xab,0x75,0x77,0x5d,0xdf,0x28,0x34,0x88,0x7c,0x7e,0x96,0x97,0xbb,0x8a,0x95,0xfe,0x07,0x65,0xf7,0x7c,0x7e,0x4c, }
}
func (t *Uint32) WriteBuffer() ([]byte, syscall.Status) {
	var buffer bytes.Buffer
	e := NewEncoder(&buffer)
	err := e.Uint32(*t)
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	err = e.Flush()
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	return buffer.Bytes(), syscall.StatusOk
}

func (t *Uint32) ReadBuffer(buffer []byte) (syscall.Status) {
	d := NewDecoder(bytes.NewBuffer(buffer))
	value, err := d.Uint32()
	if err != nil {
		return syscall.StatusFail
	}

	*t = *value
	return syscall.StatusOk
}

func (t *Uint32) GetHash() (syscall.HashValue) {
	return  syscall.HashValue{ 0xce,0xf4,0x3a,0x05,0xae,0x67,0xd9,0x73,0xc2,0xa2,0x1d,0xf8,0xcd,0xf9,0xd2,0xde,0x69,0x8d,0x0d,0xb7,0x61,0xb9,0x51,0x22,0x58,0xed,0x8f,0xb1,0x83,0xf1,0x5c,0xff,0x5b,0x84,0xe2,0x14,0x0e,0x10,0x68,0x3f,0x7a,0xd9,0xa7,0x8f,0x5b,0xe4,0x9e,0x4e,0x00,0x7d,0xcb,0xfb,0xd1,0x69,0x59,0x9d,0xbf,0x9b,0x75,0x65,0x15,0x9e,0x8b,0x82, }
}
func (t *Int64) WriteBuffer() ([]byte, syscall.Status) {
	var buffer bytes.Buffer
	e := NewEncoder(&buffer)
	err := e.Int64(*t)
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	err = e.Flush()
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	return buffer.Bytes(), syscall.StatusOk
}

func (t *Int64) ReadBuffer(buffer []byte) (syscall.Status) {
	d := NewDecoder(bytes.NewBuffer(buffer))
	value, err := d.Int64()
	if err != nil {
		return syscall.StatusFail
	}

	*t = *value
	return syscall.StatusOk
}

func (t *Int64) GetHash() (syscall.HashValue) {
	return  syscall.HashValue{ 0x56,0x16,0x70,0x35,0xd0,0x09,0x18,0x69,0x0e,0xae,0xad,0x60,0xd1,0xee,0x39,0xa8,0x61,0x45,0x58,0x5b,0x99,0x20,0x94,0x57,0x1f,0xb0,0x48,0xeb,0xb2,0xcf,0x5c,0xa5,0x8d,0xc7,0x8e,0x7e,0x3c,0x89,0xcd,0x2f,0xdc,0xf2,0x1c,0x2a,0xe3,0xd2,0x7f,0x98,0xc2,0xad,0x1c,0x3d,0x4e,0x62,0xd9,0xdb,0xc8,0xc8,0x59,0xc5,0xd5,0xc6,0xed,0x7a, }
}
func (t *Uint64) WriteBuffer() ([]byte, syscall.Status) {
	var buffer bytes.Buffer
	e := NewEncoder(&buffer)
	err := e.Uint64(*t)
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	err = e.Flush()
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	return buffer.Bytes(), syscall.StatusOk
}

func (t *Uint64) ReadBuffer(buffer []byte) (syscall.Status) {
	d := NewDecoder(bytes.NewBuffer(buffer))
	value, err := d.Uint64()
	if err != nil {
		return syscall.StatusFail
	}

	*t = *value
	return syscall.StatusOk
}

func (t *Uint64) GetHash() (syscall.HashValue) {
	return  syscall.HashValue{ 0x11,0x26,0xb3,0x0d,0x51,0x59,0x87,0x5e,0x0d,0x5b,0x93,0xfc,0x92,0xf0,0x78,0xaa,0x12,0xac,0x93,0xb8,0x30,0x1f,0x48,0x0e,0x13,0x4d,0x8b,0xfb,0x4c,0x58,0xfa,0x3a,0x69,0x6a,0x81,0x01,0xc5,0x47,0xc1,0x55,0x43,0x95,0x41,0xdf,0x3c,0x8e,0xb6,0x96,0x4a,0x3c,0x88,0xab,0x3f,0x88,0xed,0x37,0x5f,0x08,0x4a,0x41,0x8e,0xd5,0xda,0x1e, }
}
func (t *Float32) WriteBuffer() ([]byte, syscall.Status) {
	var buffer bytes.Buffer
	e := NewEncoder(&buffer)
	err := e.Float32(*t)
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	err = e.Flush()
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	return buffer.Bytes(), syscall.StatusOk
}

func (t *Float32) ReadBuffer(buffer []byte) (syscall.Status) {
	d := NewDecoder(bytes.NewBuffer(buffer))
	value, err := d.Float32()
	if err != nil {
		return syscall.StatusFail
	}

	*t = *value
	return syscall.StatusOk
}

func (t *Float32) GetHash() (syscall.HashValue) {
	return  syscall.HashValue{ 0x42,0x36,0xae,0xd3,0x62,0xca,0x34,0x75,0x94,0x52,0xf0,0x5f,0x44,0x83,0x61,0x75,0x69,0x39,0xcf,0x69,0x74,0x91,0xee,0x8d,0x35,0x8c,0xd7,0xa1,0x63,0x0f,0x88,0x86,0x6b,0x52,0xdd,0x6d,0xe1,0xb2,0x26,0xf4,0x3a,0x9c,0x9e,0xf1,0x56,0x0d,0xf1,0x48,0x07,0x39,0x46,0xf8,0xe9,0xd3,0xab,0x86,0xe0,0x1c,0x98,0x0d,0x17,0x6b,0x02,0x63, }
}
func (t *Float64) WriteBuffer() ([]byte, syscall.Status) {
	var buffer bytes.Buffer
	e := NewEncoder(&buffer)
	err := e.Float64(*t)
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	err = e.Flush()
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	return buffer.Bytes(), syscall.StatusOk
}

func (t *Float64) ReadBuffer(buffer []byte) (syscall.Status) {
	d := NewDecoder(bytes.NewBuffer(buffer))
	value, err := d.Float64()
	if err != nil {
		return syscall.StatusFail
	}

	*t = *value
	return syscall.StatusOk
}

func (t *Float64) GetHash() (syscall.HashValue) {
	return  syscall.HashValue{ 0x65,0x9b,0xb2,0x59,0x85,0xe2,0x60,0xe7,0x1e,0x12,0x17,0x3f,0xc3,0x1f,0x20,0x45,0x08,0x9e,0x7e,0x11,0x6b,0xaa,0xb3,0x1e,0x6d,0x7d,0x7a,0x5b,0xe3,0x3d,0x40,0xb5,0x40,0x06,0x52,0x85,0x37,0x80,0x2c,0xd8,0x7d,0x48,0x67,0xe3,0x9a,0xdd,0xc9,0x13,0x11,0x2c,0xa5,0xcc,0x5a,0x33,0xbc,0x35,0x6b,0x3e,0xa8,0x75,0x93,0x84,0xcf,0x1b, }
}
func (t *String) WriteBuffer() ([]byte, syscall.Status) {
	var buffer bytes.Buffer
	e := NewEncoder(&buffer)
	err := e.String(*t)
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	err = e.Flush()
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	return buffer.Bytes(), syscall.StatusOk
}

func (t *String) ReadBuffer(buffer []byte) (syscall.Status) {
	d := NewDecoder(bytes.NewBuffer(buffer))
	value, err := d.String()
	if err != nil {
		return syscall.StatusFail
	}

	*t = *value
	return syscall.StatusOk
}

func (t *String) GetHash() (syscall.HashValue) {
	return  syscall.HashValue{ 0x27,0x57,0xcb,0x3c,0xaf,0xc3,0x9a,0xf4,0x51,0xab,0xb2,0x69,0x7b,0xe7,0x9b,0x4a,0xb6,0x1d,0x63,0xd7,0x4d,0x85,0xb0,0x41,0x86,0x29,0xde,0x8c,0x26,0x81,0x1b,0x52,0x9f,0x3f,0x37,0x80,0xd0,0x15,0x00,0x63,0xff,0x55,0xa2,0xbe,0xee,0x74,0xc4,0xec,0x10,0x2a,0x2a,0x27,0x31,0xa1,0xf1,0xf7,0xf1,0x0d,0x47,0x3a,0xd1,0x8a,0x6a,0x87, }
}
func (t *Any) WriteBuffer() ([]byte, syscall.Status) {
	var buffer bytes.Buffer
	e := NewEncoder(&buffer)
	err := e.Any(*t)
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	err = e.Flush()
	if err != nil {
		return nil, syscall.StatusWriteFail
	}

	return buffer.Bytes(), syscall.StatusOk
}

func (t *Any) ReadBuffer(buffer []byte) (syscall.Status) {
	d := NewDecoder(bytes.NewBuffer(buffer))
	value, err := d.Any()
	if err != nil {
		return syscall.StatusFail
	}

	t.Value = value.Value
	return syscall.StatusOk
}
func (t *Any) GetHash() (syscall.HashValue) {
	return syscall.HashValue{0x40, 0xd3, 0x80, 0xd9, 0x2f, 0x53, 0xad, 0x12, 0xcf, 0x21, 0x94, 0x59, 0x68, 0x74, 0xa9, 0x17, 0x9f, 0x1e, 0xe3, 0xf9, 0x2e, 0x8f, 0x7c, 0x99, 0x4b, 0xf9, 0x4d, 0xb3, 0x29, 0x1a, 0xbb, 0x89, 0xc3, 0xff, 0x35, 0x1e, 0xd2, 0xb9, 0x11, 0x30, 0x15, 0x7f, 0xc7, 0xd3, 0x2f, 0x84, 0x2c, 0xed, 0x4b, 0x99, 0x8a, 0x9d, 0xe6, 0xe0, 0xe0, 0x1d, 0x98, 0x7a, 0x28, 0xd9, 0x69, 0x34, 0xe6, 0xcc}
}

